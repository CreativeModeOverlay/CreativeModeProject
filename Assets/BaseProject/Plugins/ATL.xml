<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ATL</name>
    </assembly>
    <members>
        <member name="T:ATL.AudioData.AudioDataIOFactory">
            <summary>
            Factory for audio data readers
            </summary>
        </member>
        <member name="F:ATL.AudioData.AudioDataIOFactory.CF_LOSSY">
            <summary>
            Streamed, lossy data
            </summary>
        </member>
        <member name="F:ATL.AudioData.AudioDataIOFactory.CF_LOSSLESS">
            <summary>
            Streamed, lossless data
            </summary>
        </member>
        <member name="F:ATL.AudioData.AudioDataIOFactory.CF_SEQ_WAV">
            <summary>
            Sequenced with embedded sound library
            </summary>
        </member>
        <member name="F:ATL.AudioData.AudioDataIOFactory.CF_SEQ">
            <summary>
            Sequenced with codec or hardware-dependent sound library
            </summary>
        </member>
        <member name="F:ATL.AudioData.AudioDataIOFactory.NB_CODEC_FAMILIES">
            <summary>
            Number of codec families
            </summary>
        </member>
        <member name="F:ATL.AudioData.AudioDataIOFactory.MAX_ALTERNATES">
            <summary>
            Max number of alternate formats having the same file extension
            </summary>
        </member>
        <member name="M:ATL.AudioData.AudioDataIOFactory.GetInstance">
            <summary>
            Gets the instance of this factory (Singleton pattern) 
            </summary>
            <returns>Instance of the AudioReaderFactory of the application</returns>
        </member>
        <member name="M:ATL.AudioData.AudioDataIOFactory.GetFromPath(System.String,System.Int32)">
            <summary>
            Get the proper IAudioDataIO to exploit the file at the given path,
            or a dummy object if no proper IAudioDataIO has been found
            </summary>
            <param name="path">Path of the file to exploit</param>
            <param name="alternate">Index of the alternate format to use (for internal use only)</param>
            <returns>Appropriate IAudioDataIO to exploit the file at the given path, or dummy object if no proper IAudioDataIO has been found</returns>
        </member>
        <member name="M:ATL.AudioData.AudioDataIOFactory.GetFromMimeType(System.String,System.String,System.Int32)">
            <summary>
            Get the proper IAudioDataIO to exploit the data of the given Mime-type,
            or a dummy object if no proper IAudioDataIO has been found
            </summary>
            <param name="mimeType">Mime-type of the data to exploit</param>
            <param name="path">Path of the file to exploit</param>
            <param name="alternate">Index of the alternate format to use (for internal use only)</param>
            <returns>Appropriate IAudioDataIO to exploit the data of the given Mime-type, or dummy object if no proper IAudioDataIO has been found</returns>
        </member>
        <member name="T:ATL.AudioData.AudioDataManager">
            <summary>
            Handles high-level basic operations on the given audio file, calling Metadata readers when needed
            </summary>
        </member>
        <member name="T:ATL.AudioData.AudioFileIO">
            <summary>
            This class is the one which is _really_ called when encountering a file.
            It calls AudioReaderFactory and queries AudioDataReader/MetaDataReader to provide physical 
            _and_ meta information about the given file.
            </summary>
        </member>
        <member name="M:ATL.AudioData.AudioFileIO.#ctor(System.String,System.Boolean,System.Boolean,System.IProgress{System.Single})">
            <summary>
            Constructor
            </summary>
            <param name="path">Path of the file to be parsed</param>
            <param name="readEmbeddedPictures">Embedded pictures will be read if true; ignored if false</param>
            <param name="readAllMetaFrames">All metadata frames (including unmapped ones) will be read if true; ignored if false</param>
            <param name="writeProgress">Object to use to signal writing progress (optional)</param>
        </member>
        <member name="M:ATL.AudioData.AudioFileIO.#ctor(System.IO.Stream,System.String,System.Boolean,System.Boolean,System.IProgress{System.Single})">
            <summary>
            Constructor
            </summary>
            <param name="stream">Stream to access in-memory data to be parsed</param>
            <param name="mimeType">Mime-type of the stream to process</param>
            <param name="readEmbeddedPictures">Embedded pictures will be read if true; ignored if false</param>
            <param name="readAllMetaFrames">All metadata frames (including unmapped ones) will be read if true; ignored if false</param>
            <param name="writeProgress">Object to use to signal writing progress (optional)</param>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.FileName">
            <summary>
            Audio file name
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Title">
            <summary>
            Title of the track
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Artist">
            <summary>
            Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Composer">
            <summary>
            Composer
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Publisher">
            <summary>
            Publisher
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.PublishingDate">
            <summary>
            Publishing Date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Conductor">
            <summary>
            Conductor
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.AlbumArtist">
            <summary>
            Album Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.GeneralDescription">
            <summary>
            General description
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Copyright">
            <summary>
            Copyright
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.OriginalArtist">
            <summary>
            Original artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.OriginalAlbum">
            <summary>
            Original album
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.PaddingSize">
            <summary>
            Size of the padding zone, if any
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Comment">
            <summary>
            Comments
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.PictureTokens">
            <summary>
            Flag indicating the presence of embedded pictures
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Genre">
            <summary>
            Genre
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Track">
            <summary>
            Track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.TrackTotal">
            <summary>
            Total track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Disc">
            <summary>
            Disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.DiscTotal">
            <summary>
            Total disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.IntYear">
            <summary>
            Year, converted to int
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Album">
            <summary>
            Album title
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.IntDuration">
            <summary>
            Track duration (seconds), rounded
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.IntBitRate">
            <summary>
            Track bitrate (KBit/s), rounded
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Popularity">
            <summary>
            Track rating
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.AudioFormat">
            <summary>
            Format of audio data
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.CodecFamily">
            <summary>
            Codec family
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.IsVBR">
            <summary>
            Indicates whether the audio stream is in VBR
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Exists">
            <summary>
            Does the tag exist ?
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.MetadataFormats">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Date">
            <summary>
            Recording date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Year">
            <summary>
            Year, in its original form
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.BitRate">
            <summary>
            Track bitrate (Kbit/s)
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.SampleRate">
            <summary>
            Sample rate (Hz)
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Duration">
            <summary>
            Track duration (milliseconds)
            </summary>
        </member>
        <member name="P:ATL.AudioData.AudioFileIO.Size">
            <summary>
            Metadata size (bytes)
            </summary>
        </member>
        <member name="T:ATL.AudioData.CrossMetadataReader">
            <summary>
            Wrapper for reading multiple tags according to a priority
            
            Rule : The first non-empty field of the most prioritized tag becomes the "cross-detected" field
            There is no "field blending" across collections (pictures, additional fields) : the first non-empty collection is kept
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Exists">
            <summary>
            Returns true if this kind of metadata exists in the file, false if not
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.MetadataFormats">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Title">
            <summary>
            Title of the track
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Artist">
            <summary>
            Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Composer">
            <summary>
            Composer
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Comment">
            <summary>
            Comments
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Genre">
            <summary>
            Genre
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Track">
            <summary>
            Track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.TrackTotal">
            <summary>
            Total track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Disc">
            <summary>
            Disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.DiscTotal">
            <summary>
            Total disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Date">
            <summary>
            Recording date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Year">
            <summary>
            Year
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Album">
            <summary>
            Title of the album
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Copyright">
            <summary>
            Copyright
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.AlbumArtist">
            <summary>
            Album Arist
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Conductor">
            <summary>
            Conductor
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Publisher">
            <summary>
            Publisher
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.PublishingDate">
            <summary>
            Publishing date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.GeneralDescription">
            <summary>
            General description
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.OriginalArtist">
            <summary>
            Original artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.OriginalAlbum">
            <summary>
            Original album
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.PaddingSize">
            <summary>
            Size of the padding area, if any
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.PictureTokens">
            <summary>
            List of picture IDs stored in the tag
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.AdditionalFields">
            <summary>
            Any other metadata field that is not represented among above getters
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Chapters">
            <summary>
            Chapters
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.Lyrics">
            <summary>
            Lyrics
            </summary>
        </member>
        <member name="P:ATL.AudioData.CrossMetadataReader.EmbeddedPictures">
            <summary>
            Embedded pictures
            </summary>
        </member>
        <member name="T:ATL.AudioData.IAudioDataIO">
            <summary>
            This Interface defines an object aimed at giving audio "physical" data information
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.FileName">
            <summary>
            Full access path of the underlying file
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.BitRate">
            <summary>
            Bitrate (kilobytes per second)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.Duration">
            <summary>
            Duration (milliseconds)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.SampleRate">
            <summary>
            Sample rate (Hz)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.IsVBR">
            <summary>
            Returns true if the bitrate is variable; false if not
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.AudioFormat">
            <summary>
            Format of the audio data
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.CodecFamily">
            <summary>
            Family of the audio codec (see AudioDataIOFactory for the list of codec families)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IAudioDataIO.ChannelsArrangement">
            <summary>
            Channels arrangement
            </summary>
        </member>
        <member name="M:ATL.AudioData.IAudioDataIO.IsMetaSupported(System.Int32)">
            <summary>
            Indicated whether the given metadata type is supported
            </summary>
            <param name="metaDataType">Metadata type to be tested (see list in MetaDataIOFactory)</param>
            <returns>True if current file supports the given metadata type; false if not</returns>
        </member>
        <member name="M:ATL.AudioData.IAudioDataIO.Read(System.IO.BinaryReader,ATL.AudioData.AudioDataManager.SizeInfo,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <summary>
            Reads audio data from the given stream.
            NB1 : Standard metadata (i.e. ID3v2, ID3v1 and APE) have to be read _before_ calling this method, and their size stored in sizeInfo
            NB2 : Stream is _not_ closed after reading; resource deallocation has to be done by the caller
            </summary>
            <param name="source">BinaryReader opened on the stream to read</param>
            <param name="sizeInfo">Description of the size of the undelying stream and associated metadata</param>
            <param name="readTagParams">Reading parameters and options</param>
            <returns>True if the stream has been successfuly read; false if not</returns>
        </member>
        <member name="T:ATL.AudioData.IMetaDataEmbedder">
            <summary>
            Describes an audio file that embeds standard metadata (e.g. ID3v2) in a native structure instead of keeping it at beginning/end of file as per standard use
            Currently used for AIFF/AIFC and DSF embedded ID3v2
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataEmbedder.HasEmbeddedID3v2">
            <summary>
            Indicates if file format has an embedded ID3v2 tag
            Return values
                -1 : Allowed by file format; status unknown because file has not been read yet
                0  : Allowed by file format, but not detected on this particular file
                >0 : Offset of detected embedded ID3v2
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataEmbedder.ID3v2EmbeddingHeaderSize">
            <summary>
            Size of the native header that precedes the ID3v2 embedded tag, if any (0 if no header)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataEmbedder.Id3v2Zone">
            <summary>
            Zone containing the ID3v2 tag
            </summary>
        </member>
        <member name="M:ATL.AudioData.IMetaDataEmbedder.WriteID3v2EmbeddingHeader(System.IO.BinaryWriter,System.Int64)">
            <summary>
            Writes the native header that precedes the ID3v2 embedded tag in the given stream, using the given tag size
            </summary>
            <param name="w">Stream to write the header to</param>
            <param name="tagSize">Tag size to be documented in the header to be written</param>
        </member>
        <member name="T:ATL.AudioData.IMetaDataIO">
            <summary>
            This Interface defines an object aimed at giving audio metadata information
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Exists">
            <summary>
            Returns true if this kind of metadata exists in the file, false if not
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.MetadataFormats">
            <summary>
            Available metadata formats
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Title">
            <summary>
            Title of the track
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Artist">
            <summary>
            Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Composer">
            <summary>
            Composer
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Comment">
            <summary>
            Comments
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Genre">
            <summary>
            Genre
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Track">
            <summary>
            Track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.TrackTotal">
            <summary>
            Total track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Disc">
            <summary>
            Disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.DiscTotal">
            <summary>
            Total disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Date">
            <summary>
            Recording date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Year">
            <summary>
            Recording Year
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Album">
            <summary>
            Title of the album
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Popularity">
            <summary>
            Rating of the track, from 0% to 100%
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Copyright">
            <summary>
            Copyright
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.OriginalArtist">
            <summary>
            Original artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.OriginalAlbum">
            <summary>
            Title of the original album
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.GeneralDescription">
            <summary>
            General description
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Publisher">
            <summary>
            Publisher
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.PublishingDate">
            <summary>
            Publishing Date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.AlbumArtist">
            <summary>
            Album Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Conductor">
            <summary>
            Conductor
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.PaddingSize">
            <summary>
            Size of padding area, if any
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.PictureTokens">
            <summary>
            List of picture IDs stored in the tag
                PictureInfo.PIC_TYPE : internal, normalized picture type
                PictureInfo.NativePicCode : native picture code (useful when exploiting the UNSUPPORTED picture type)
                NB : PictureInfo.PictureData (raw binary picture data) is _not_ valued here; see EmbeddedPictures field
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Size">
            <summary>
            Physical size of the tag (bytes)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.AdditionalFields">
            <summary>
            Contains any other metadata field that is not represented by a getter in the above interface
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.ChaptersTableDescription">
            <summary>
            Chapters table of contents description
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Chapters">
            <summary>
            Chapters
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.Lyrics">
            <summary>
            Lyrics
            </summary>
        </member>
        <member name="P:ATL.AudioData.IMetaDataIO.EmbeddedPictures">
            <summary>
            List of pictures stored in the tag
            NB : PictureInfo.PictureData (raw binary picture data) is valued
            </summary>
        </member>
        <member name="M:ATL.AudioData.IMetaDataIO.SetEmbedder(ATL.AudioData.IMetaDataEmbedder)">
            <summary>
            Set metadata to be written using the given embedder
            </summary>
            <param name="embedder">Metadata embedder to be used to write current metadata</param>
        </member>
        <member name="M:ATL.AudioData.IMetaDataIO.Read(System.IO.BinaryReader,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <summary>
            Parse binary data read from the given stream
            </summary>
            <param name="source">Reader to parse data from</param>
            <param name="readTagParams">Tag reading parameters</param>
            <returns>true if the operation suceeded; false if not</returns>
        </member>
        <member name="M:ATL.AudioData.IMetaDataIO.Write(System.IO.BinaryReader,System.IO.BinaryWriter,ATL.TagData,System.IProgress{System.Single})">
            <summary>
            Add the specified information to current tag information :
              - Any existing field is overwritten
              - Any non-specified field is kept as is
            </summary>
            <param name="r">Reader to the resource to edit</param>
            <param name="w">Writer to the resource to edit</param>
            <param name="tag">Tag information to be added</param>
            <param name="writeProgress">Progress to be updated during write operations</param>
            <returns>true if the operation suceeded; false if not</returns>
        </member>
        <member name="M:ATL.AudioData.IMetaDataIO.Remove(System.IO.BinaryWriter)">
            <summary>
            Remove current tag
            </summary>
            <param name="w">Writer to the resource to edit</param>
            <returns>true if the operation suceeded; false if not</returns>
        </member>
        <member name="M:ATL.AudioData.IMetaDataIO.Clear">
            <summary>
            Clears all metadata
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.AA">
            <summary>
            Class for Audible Formats 2 to 4 files manipulation (extensions : .AA)
            
            Implementation notes
            
              - Only the editing of existing zones has been tested, not the adding of new zones (e.g. tagging a tagless AA, adding a picture to a pictureless AA)
              due to the lack of empty test files
              
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.AAC">
            <summary>
            Class for Advanced Audio Coding files manipulation (extensions : .AAC)
            
            Implementation notes
            
                1. LATM and LOAS/LATM support is missing
            
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.AC3">
            <summary>
            Class for Dolby Digital files manipulation (extension : .AC3)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.AIFF">
            <summary>
            Class for Audio Interchange File Format files manipulation (extension : .AIF, .AIFF, .AIFC)
            
            Implementation notes
            
             1/ Annotations being somehow deprecated (Cf. specs "Use of this chunk is discouraged within FORM AIFC. The more refined Comments Chunk should be used instead"),
             any data read from an ANNO chunk will be written as a COMT chunk when updating the file (ANNO chunks will be deleted in the process).
            
             2/ Embedded MIDI detection, parsing and writing is not supported
             
             3/ Instrument detection, parsing and writing is not supported
            </summary>
        </member>
        <member name="M:ATL.AudioData.IO.AIFF.seekNextChunkHeader(System.IO.BinaryReader,System.Int64)">
            <summary>
            Reads ID and size of a local chunk and returns them in a dedicated structure _without_ reading nor skipping the data
            </summary>
            <param name="source">Source where to read header information</param>
            <returns>Local chunk header information</returns>
        </member>
        <member name="T:ATL.AudioData.IO.APE">
            <summary>
            Class for Monkey's Audio file manipulation (extension : .APE)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.APEtag">
            <summary>
            Class for APEtag 1.0 and 2.0 tags manipulation
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.APEtag.APE_ID">
            <summary>
            Tag ID / magic number
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.APEtag.APE_TAG_FOOTER_SIZE">
            <summary>
            APE tag footer size
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.APEtag.APE_TAG_HEADER_SIZE">
            <summary>
            APE tag header size
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.APEtag.APE_VERSION_1_0">
            <summary>
            APE v1
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.APEtag.APE_VERSION_2_0">
            <summary>
            APE v2
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.APEtag.MetadataFormats">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.APEtag.getDefaultTagOffset">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.APEtag.getImplementedTagType">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.APEtag.ratingConvention">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.APEtag.getFrameMapping(System.String,System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.APEtag.write(ATL.TagData,System.IO.BinaryWriter,System.String)">
            <summary>
            Writes the given tag into the given Writer using APEv2 conventions
            </summary>
            <param name="tag">Tag information to be written</param>
            <param name="w">Stream to write tag information to</param>
            <param name="zone">Code of the zone to write</param>
            <returns>True if writing operation succeeded; false if not</returns>
        </member>
        <member name="T:ATL.AudioData.IO.DSF">
            <summary>
            Class for DSD Stream File files manipulation (extension : .DSF)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.DTS">
            <summary>
            Class for Digital Theatre System files manipulation (extension : .DTS)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.DummyReader">
            <summary>
            Dummy audio data provider
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.FileName">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.BitRate">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.Duration">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.SampleRate">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.IsVBR">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.AudioFormat">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.CodecFamily">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.ID3v1">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.ID3v2">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.APEtag">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.NativeTag">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyReader.ChannelsArrangement">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.DummyReader.RemoveTagFromFile(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.DummyReader.AddTagToFile(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.DummyReader.UpdateTagInFile(ATL.TagData,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.DummyReader.IsMetaSupported(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.DummyReader.Read(System.IO.BinaryReader,ATL.AudioData.AudioDataManager.SizeInfo,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <inheritdoc/>
        </member>
        <member name="T:ATL.AudioData.IO.DummyTag">
            <summary>
            Dummy metadata provider
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Exists">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.MetadataFormats">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Title">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Artist">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Composer">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Comment">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Genre">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Track">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.TrackTotal">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Disc">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.DiscTotal">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Date">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Year">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Album">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Popularity">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Size">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.PictureTokens">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Copyright">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.OriginalArtist">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.OriginalAlbum">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.GeneralDescription">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Publisher">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.PublishingDate">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.AlbumArtist">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Conductor">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.PaddingSize">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.ChaptersTableDescription">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.AdditionalFields">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Chapters">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.Lyrics">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.DummyTag.EmbeddedPictures">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.DummyTag.Write(System.IO.BinaryReader,System.IO.BinaryWriter,ATL.TagData,System.IProgress{System.Single})">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.DummyTag.Read(System.IO.BinaryReader,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.DummyTag.Remove(System.IO.BinaryWriter)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.DummyTag.SetEmbedder(ATL.AudioData.IMetaDataEmbedder)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.DummyTag.Clear">
            <inheritdoc/>
        </member>
        <member name="T:ATL.AudioData.IO.FLAC">
            <summary>
            Class for Free Lossless Audio Codec files manipulation (extension : .FLAC)
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.FLAC.initialPictures">
            <summary>
             Write-time vars (TODO - find a better place than the whole class scope)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.FLAC.MetadataFormats">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.FLAC.adjustPictureZones(System.Collections.Generic.IList{ATL.PictureInfo})">
            <summary>
            Adjust the number of picture zones to match the actual number of pictures to be written
            </summary>
            <param name="picturesToWrite">List of pictures to be written</param>
        </member>
        <member name="M:ATL.AudioData.IO.FLAC.processPictureBlock(System.IO.BinaryWriter,System.Collections.Generic.IList{ATL.PictureInfo},System.Collections.Generic.IList{ATL.PictureInfo},System.Int32@,System.Int32@)">
            <summary>
            Process picture block at the index 'targetPictureIndex'
            Three outcomes :
                1/ Target picture cannot be written => block is marked for deletion
                2/ Target picture can be written and is identical to existing picture at the same position => block is left as it is
                3/ Target picture can be written and is different to existing picture at the same position => target picture is written
            </summary>
            <param name="w">Writer to be used</param>
            <param name="existingPictures">List of existing pictures on the file</param>
            <param name="picturesToWrite">List of pictures to write</param>
            <param name="existingPictureIndex">Current index of existing pictures in use in the main write loop</param>
            <param name="targetPictureIndex">Current index of target pictures in use in the main write loop</param>
            <returns></returns>
        </member>
        <member name="T:ATL.AudioData.IO.GYM">
            <summary>
            Class for Genesis YM2612 files manipulation (extensions : .GYM)
            
            Implementation notes
            
                1/ Looping : I have yet to find a GYM file that actually contains a loop.
                All archives I found so far are direct recording of game audio instructions
                that actually repeat the same pattern twice (looping data is not used at all)
                
                2/ Gzipped stream : I have yet to find a GYM file that contains gzipped data.
                => Rather than to make a theoretical implementation, there is no implementation at all.
            
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.ID3v1">
            <summary>
            Class for ID3v1.0-1.1 tags manipulation
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.ID3v1.MAX_MUSIC_GENRES">
            <summary>
            Max. number of music genres
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.ID3v1.ID3V1_TAG_SIZE">
            <summary>
            Standard size of an ID3v1 tag
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.ID3v1.ID3V1_ID">
            <summary>
            Magic number of an ID3v1 tag
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.ID3v1.TAG_VERSION_1_0">
            <summary>
            Index for ID3v1.0 tag
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.ID3v1.TAG_VERSION_1_1">
            <summary>
            Index for ID3v1.1 tag
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.ID3v1.MetadataFormats">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v1.getDefaultTagOffset">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v1.getImplementedTagType">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v1.getFrameMapping(System.String,System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v1.write(ATL.TagData,System.IO.BinaryWriter,System.String)">
            <summary>
            Writes the given metadata into the given stream using the ID3v1.1 standard
            NB : Metadata fields that are not supported by ID3v1.1 standard (e.g. Composer) won't be written into the stream, even though their value are set
            </summary>
            <param name="tag">Metadata to be written</param>
            <param name="w">Stream to be used</param>
            <returns>True if operation completed successfuly; else false</returns>
        </member>
        <member name="T:ATL.AudioData.IO.ID3v2">
             <summary>
             Class for ID3v2.2-2.4 tags manipulation
             
             Implementation notes
             
                 1. Extended header tags
             
                 Due to the rarity of ID3v2 tags with extended headers (on my disk and on the web), 
                 implementation of decoding extended header data has been tested on _forged_ files. Implementation might not be 100% real-world proof.
                 
                 2. Hierarchical table of contents (CTOC)
                 
                 ID3v2 chapters specification allows multiple CTOC frames in the tag, in order to describe a multiple-level table of contents.
                 (see informal standard  id3v2-chapters-1.0.html)
                 
                 This feature is currently not supported. If any CTOC is detected while reading, ATL will "blindly" write a flat CTOC containing
                 all chapters. Any hierarchical table of contents will be lost while rewriting.
                 
                 3. Unsynchronization and Unicode
                 
                 Little-endian UTF-16 BOM's are caught by the unsynchronization encoding, which "breaks" most tag readers.
                 Hence unsycnhronization is force-disabled when text encoding is Unicode.
            
                 4. Unsynchronization at frame level
                 
                 Even though ID3v2.4 allows it, ATL does not support "individual" unsynchronization at frame level
                 => Either the whole tag (all frames) is unsynchronized, or none is
            
                 5. Windows explorer, embedded pictures and ID3v2.4
                 
                 ATL is not able to guarantee a tag saved with ID3v2.4 will have its embedded picture visible from Windows Explorer
                 It seems there's a magic formula to do that because MP3tag does it well. So far I haven't found it.
                 => If you want to save ID3v2 tags and view the embedded pictures on Windows Explorer, please save the tag using ID3v2.3
                 (set Settings.ID3v2_tagSubVersion = 3)
             
             </summary>
        </member>
        <member name="F:ATL.AudioData.IO.ID3v2.TAG_VERSION_2_2">
            <summary>
            ID3v2.2
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.ID3v2.TAG_VERSION_2_3">
            <summary>
            ID3v2.3
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.ID3v2.TAG_VERSION_2_4">
            <summary>
            ID3v2.4
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.ID3v2.MetadataFormats">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v2.getDefaultTagOffset">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v2.getImplementedTagType">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.ID3v2.FieldCodeFixedLength">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v2.Read(System.IO.BinaryReader,System.Int64,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <summary>
            Reads ID3v2 data
            </summary>
            <param name="source">Reader object from where to read ID3v2 data</param>
            <param name="pictureStreamHandler">If not null, handler that will be triggered whenever a supported embedded picture is read</param>
            <param name="offset">ID3v2 header offset (mostly 0, except for specific audio containers such as AIFF or DSF)</param>
            <param name="storeUnsupportedMetaFields">Indicates whether unsupported fields should be read and stored in memory (optional; default = false)</param>
            <returns></returns>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v2.write(ATL.TagData,System.IO.BinaryWriter,System.String)">
            <summary>
            Writes the given tag into the given Writer using ID3v2.4 conventions
            </summary>
            <param name="tag">Tag information to be written</param>
            <param name="w">Stream to write tag information to</param>
            <returns>True if writing operation succeeded; false if not</returns>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v2.extractGenreFromID3v2Code(System.String)">
            <summary>
            Extract genre name from String according to ID3 conventions
            </summary>
            <param name="iGenre">String representation of genre according to various ID3v1/v2 conventions</param>
            <returns>Genre name</returns>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v2.readBOM(System.IO.Stream)">
            <summary>
            Read Unicode BOM and return the corresponding encoding
            NB : This implementation _only_ works with UTF-16 BOMs defined in the ID3v2 specs ($FF FE 00 00 or $FE FF 00 00)
            </summary>
            <param name="source">Source stream</param>
            <returns>Properties of the BOM.
            If it has been found, stream is positioned on the next byte just after the BOM.
            If not, stream is positioned on its initial position before calling readBOM.
            </returns>
        </member>
        <member name="M:ATL.AudioData.IO.ID3v2.decodeID3v2CharEncoding(System.Byte)">
             Returns the .NET Encoding corresponding to the ID3v2 convention (see below)
            
             Default encoding should be "ISO-8859-1"
             
             Warning : due to approximative implementations, some tags seem to be coded
             with the default encoding of the OS they have been tagged on
             
              $00    ISO-8859-1 [ISO-8859-1]. Terminated with $00.
              $01    UTF-16 [UTF-16] encoded Unicode [UNICODE], with BOM if version > 2.2
                     All strings in the same frame SHALL have the same byteorder.
                     Terminated with $00 00.
              $02    UTF-16BE [UTF-16] encoded Unicode [UNICODE] without BOM.
                     Terminated with $00 00.
              $03    UTF-8 [UTF-8] encoded Unicode [UNICODE]. Terminated with $00.
        </member>
        <member name="T:ATL.AudioData.IO.IT">
            <summary>
            Class for Impulse Tracker Module files manipulation (extensions : .IT)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.Midi">
            <summary>
            Class for Musical Instruments Digital Interface files manipulation (extension : .MID, .MIDI)
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.Midi.tracks">
            <summary>
            Tracks of the song
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.Midi.timebase">
            <summary>
            Timebase = ticks per frame (quarter note) a.k.a. PPQN (Pulses Per Quarter Note)
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.Midi.tempo">
            <summary>
            Tempo (0 for unknown)
            NB : there is no such thing as an uniform "song tempo" since tempo can change over time within each track !
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.Midi.type">
            <summary>
            MIDI structure type
              0 - single-track
              1 - multiple tracks, synchronous
              2 - multiple tracks, asynchronous
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.Midi.SampleRate">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.Midi.IsVBR">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.Midi.AudioFormat">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.Midi.CodecFamily">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.Midi.FileName">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.Midi.BitRate">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.Midi.Duration">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.Midi.ChannelsArrangement">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.Midi.IsMetaSupported(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.Midi.getDefaultTagOffset">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.Midi.getImplementedTagType">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.Midi.getFrameMapping(System.String,System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.Midi.read(System.IO.BinaryReader,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <inheritdoc/>
        </member>
        <member name="M:ATL.AudioData.IO.Midi.write(ATL.TagData,System.IO.BinaryWriter,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:ATL.AudioData.IO.MOD">
            <summary>
            Class for Noisetracker/Soundtracker/Protracker Module files manipulation (extensions : .MOD)
            Based on info obtained from Thunder's readme (MODFIL10.TXT - Version 1.0)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.MP4">
            <summary>
            Class for MP4 files manipulation (extensions : .MP4, .M4A, .M4B, .M4V)
            
            Implementation notes
            
            </summary>
        </member>
        <member name="M:ATL.AudioData.IO.MP4.readMP4(System.IO.BinaryReader,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <summary>
            Read MP4 header data
            http://www.jiscdigitalmedia.ac.uk/guide/aac-audio-and-the-mp4-media-format
            http://atomicparsley.sourceforge.net/mpeg-4files.html
            https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html
            - Metadata is located in the moov/udta/meta/ilst atom
            - Physical metadata are located in the moov/trak atoms
            - Binary physical data are located in the mdat atoms
            </summary>
            <param name="source">Source to read from</param>
            <param name="readTagParams">Reading parameters</param>
        </member>
        <member name="M:ATL.AudioData.IO.MP4.lookForMP4Atom(System.IO.Stream,System.String)">
            <summary>
            Looks for the atom segment starting with the given key, at the current atom level
            Returns with Source positioned right after the atom header, on the 1st byte of data
            
            Warning : stream must be positioned at the end of a previous atom before being called
            </summary>
            <param name="Source">Source to read from</param>
            <param name="atomKey">Atom key to look for (e.g. "udta")</param>
            <returns>If atom found : raw size of the atom (including the already-read 8-byte header);
            If atom not found : 0</returns>
        </member>
        <member name="T:ATL.AudioData.IO.MPEGaudio">
            <summary>
            Class for MPEG Audio Layer files manipulation (extensions : .MP1, .MP2, .MP3)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.MPEGplus">
            <summary>
            Class for MusePack / MPEGplus files manipulation (extensions : .MPC, .MP+)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.Ogg">
            <summary>
            Class for OGG files manipulation. Current implementation covers :
              - Vorbis data (extensions : .OGG)
              - Opus data (extensions : .OPUS)
              
            Implementation notes
            
              1. CRC's : Current implementation does not test OGG page header CRC's
              2. Page numbers : Current implementation does not test page numbers consistency
            
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.Ogg.MetadataFormats">
            <inheritdoc/>
        </member>
        <member name="T:ATL.AudioData.IO.OptimFrog">
            <summary>
            Class for OptimFROG files manipulation (extensions : .OFR, .OFS)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.PSF">
            <summary>
            Class for Portable Sound Format files manipulation (extensions : .PSF, .PSF1, .PSF2, 
            .MINIPSF, .MINIPSF1, .MINIPSF2, .SSF, .MINISSF, .DSF, .MINIDSF, .GSF, .MINIGSF, .QSF, .MINISQF)
            According to Neil Corlett's specifications v. 1.6
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.S3M">
            <summary>
            Class for ScreamTracker Module files manipulation (extensions : .S3M)
            
            Note : Parsing as it is considers the file as one single song. 
            Modules with song delimiters (pattern code 0xFF) are supported, but displayed as one track
            instead of multiple tracks (behaviour of foobar2000).
            
            As a consequence, modules containing multiple songs and exotic loops (i.e. looping from song 2 to song 1)
            might not be detected with their exact duration.
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.SPC">
            <summary>
            Class for SPC700 files manipulation (extensions : .SPC)
            According to file format v0.30; inspired by the SNESamp source (ID666.cpp)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.TAK">
            <summary>
            Class for Tom's lossless Audio Kompressor files manipulation (extension : .TAK)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.TTA">
            <summary>
            Class for True Audio files manipulation (extensions : .TTA)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.TwinVQ">
            <summary>
            Class for TwinVQ files manipulation (extension : .VQF)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.VGM">
            <summary>
            Class for Video Game Music files (Master System, Game Gear, SG1000, Genesis) manipulation (extensions : .VGM)
            According to file format v1.70
            
            Implementation notes :
              1/ GD3 tag format is directly implemented in here, since it is not a "real" standard and is only used for VGM files
              
              2/ Gzipped files are currently supported in read-only mode (i.e. ATL cannot write metadata to a GYM file containing gzipped data)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.VorbisTag">
            <summary>
            Class for Vorbis tags (VorbisComment) manipulation
            
            TODO - Rewrite as "pure" helper, with Ogg and FLAC inheriting MetaDataIO
            
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.WAV">
            <summary>
            Class for PCM (uncompressed audio) files manipulation (extension : .WAV)
            
            Implementation notes
            
                1. BEXT metadata - UMID field
                
                UMID field is decoded "as is" using the hex notation. No additional interpretation has been done so far.
                
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.WAVPack">
            <summary>
            Class for WavPack files manipulation (extension : .WV)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.WMA">
            <summary>
            Class for Windows Media Audio 7,8 and 9 files manipulation (extension : .WMA)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.XM">
            <summary>
            Class for Extended Module files manipulation (extensions : .XM)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.MetaDataIO">
            <summary>
            Superclass that "consolidates" all metadata I/O algorithms to ease development of new classes and minimize their code
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.MetaDataIO.ReadTagParams">
            <summary>
            Container class describing tag reading parameters
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.MetaDataIO.ReadTagParams.ReadTag">
            <summary>
            True : read metadata; False : do not read metadata (only "physical" audio data)
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.MetaDataIO.ReadTagParams.ReadAllMetaFrames">
            <summary>
            True : read all metadata frames; False : only read metadata frames that match IMetaDataIO public properties (="supported" metadata)
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.MetaDataIO.ReadTagParams.ReadPictures">
            <summary>
            True : read embedded pictures; False : skip embedded pictures
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.MetaDataIO.ReadTagParams.PrepareForWriting">
            <summary>
            True : read all data that will be useful for writing; False : only read metadata values
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.MetaDataIO.ReadTagParams.offset">
            <summary>
            File offset to start reading metadata from (bytes)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Exists">
            <summary>
            True if tag has been found in media file
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.MetadataFormats">
            <inheritdoc/>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Version">
            <summary>
            Tag version
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Size">
            <summary>
            Total size of tag (in bytes)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Title">
            <summary>
            Song/piece title
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Artist">
            <summary>
            Artist (Performer)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.AlbumArtist">
            <summary>
            Album Artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Composer">
            <summary>
            Composer
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Album">
            <summary>
            Album title
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Track">
            <summary>
            Track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.TrackTotal">
            <summary>
            Total track number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Disc">
            <summary>
            Disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.DiscTotal">
            <summary>
            Total disc number
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Popularity">
            <summary>
            Rating, from 0 to 100%
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Year">
            <summary>
            Release year
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Date">
            <summary>
            Recording date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.PublishingDate">
            <summary>
            Publishing date (DateTime.MinValue if field does not exist)
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Genre">
            <summary>
            Genre name
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Comment">
            <summary>
            Commment
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Copyright">
            <summary>
            Copyright
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.OriginalArtist">
            <summary>
            Original artist
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.OriginalAlbum">
            <summary>
            Original album
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.GeneralDescription">
            <summary>
            General Description
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Publisher">
            <summary>
            Publisher
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.Conductor">
            <summary>
            Conductor
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.PaddingSize">
            <summary>
            Size of padding zone, if any
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.AdditionalFields">
            <summary>
            Collection of fields that are not supported by ATL (i.e. not implemented by a getter/setter of MetaDataIO class; e.g. custom fields such as "MOOD")
            NB : when querying multi-stream files (e.g. MP4, ASF), this attribute will only return stream-independent properties of the whole file, in the first language available
            For detailed, stream-by-stream and language-by-language properties, use GetAdditionalFields
            </summary>
        </member>
        <member name="P:ATL.AudioData.IO.MetaDataIO.PictureTokens">
            <summary>
            Each positioned flag indicates the presence of an embedded picture
            </summary>
        </member>
        <member name="M:ATL.AudioData.IO.MetaDataIO.read(System.IO.BinaryReader,ATL.AudioData.IO.MetaDataIO.ReadTagParams)">
            <summary>
            Read metadata from the given source, using the given parameters
            </summary>
            <param name="source">Source to read metadata from</param>
            <param name="readTagParams">Read parameters</param>
            <returns>True if read has been successful, false if it failed</returns>
        </member>
        <member name="M:ATL.AudioData.IO.MetaDataIO.write(ATL.TagData,System.IO.BinaryWriter,System.String)">
            <summary>
            Write the given zone's metadata using the given writer
            </summary>
            <param name="tag">Metadata to write</param>
            <param name="w">Writer to use</param>
            <param name="zone">Code of the zone to write</param>
            <returns>Number of written fields; 0 if no field has been added not edited</returns>
        </member>
        <member name="M:ATL.AudioData.IO.MetaDataIO.getDefaultTagOffset">
            <summary>
            Return the default offset of the metadata block
            </summary>
            <returns></returns>
        </member>
        <member name="M:ATL.AudioData.IO.MetaDataIO.getImplementedTagType">
            <summary>
            Return the implemented tag type (see <see cref="T:ATL.AudioData.MetaDataIOFactory"/> constants)
            TODO make it return a <see cref="T:ATL.AudioData.MetaDataIOFactory.TagType"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ATL.AudioData.IO.MetaDataIO.getFrameMapping(System.String,System.String,System.Byte)">
            <summary>
            Get the frame code (per <see cref="T:ATL.TagData"/> standards for the given field ID in the given zone and the given tag version
            </summary>
            <param name="zone">Code of the zone of the given field</param>
            <param name="ID">ID of the field to get the mapping for</param>
            <param name="tagVersion">Version the tagging system (e.g. 3 for ID3v2.3)</param>
            <returns></returns>
        </member>
        <member name="T:ATL.AudioData.IO.FileSurgeon">
            <summary>
            Helper class called to write into files, optimizing memory and I/O speed according to the rewritten areas
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.FileSurgeon.WriteMode">
            <summary>
            Modes for zone block modification
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.FileSurgeon.WriteMode.REPLACE">
            <summary>
            Replace : existing block is replaced by written data
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.FileSurgeon.WriteMode.OVERWRITE">
            <summary>
            Overwrite : written data overwrites existing block (non-overwritten parts are kept as is)
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.FileSurgeon.ZoneManagement">
            <summary>
            Modes for zone management
            NB : ON_DISK mode can be forced client-side by using <see cref="F:ATL.Settings.ForceDiskIO"/>
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.FileSurgeon.ZoneManagement.ON_DISK">
            <summary>
            Modifications are performed directly on disk; adapted for small files or single zones
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.FileSurgeon.ZoneManagement.BUFFERED">
            <summary>
            Modifications are performed in a memory buffer, then written on disk in one go
            </summary>
        </member>
        <member name="T:ATL.AudioData.IO.FileSurgeon.ZoneRegion">
            <summary>
            Buffering region
            Describes a group of overlapping, contiguous or neighbouring <see cref="T:ATL.AudioData.FileStructureHelper.Zone"/>s that can be buffered together for I/O optimization
            Two Zones stop belonging to the same region if they are distant by more than <see cref="F:ATL.AudioData.IO.FileSurgeon.REGION_DISTANCE_THRESHOLD"/>% of the total file size
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.FileSurgeon.ZoneRegion.Id">
            <summary>
            ID of the region
            Used for computation purposes only
            Must be unique 
            Must be different than -1 which is a reserved value for "unbuffered area" used in <see cref="T:ATL.AudioData.FileStructureHelper"/>
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.FileSurgeon.ZoneRegion.IsBufferable">
            <summary>
            True if the region is bufferable; false if not (i.e. non-resizable zones)
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.FileSurgeon.ZoneRegion.Zones">
            <summary>
            Zones belonging to the region
            </summary>
        </member>
        <member name="F:ATL.AudioData.IO.FileSurgeon.REGION_DISTANCE_THRESHOLD">
            <summary>
            % of total stream (~file) size under which two neighbouring Zones can be grouped into the same Region
            </summary>
        </member>
        <member name="M:ATL.AudioData.IO.FileSurgeon.RewriteZones(System.IO.BinaryWriter,ATL.AudioData.IO.FileSurgeon.WriteDelegate,System.Collections.Generic.ICollection{ATL.AudioData.FileStructureHelper.Zone},ATL.TagData,System.Boolean,System.Boolean)">
            <summary>
            Rewrites zones that have to be rewritten
                - Works region after region, buffering them if needed
                - Put each zone into memory and update them using the given WriteDelegate
                - Adjust file size and region headers accordingly
            </summary>
            <param name="fullScopeWriter">BinaryWriter opened on the data stream (usually, contents of an audio file) to be rewritten</param>
            <param name="write">Delegate to the write method of the <see cref="T:ATL.AudioData.IMetaDataIO"/> to be used to update the data stream</param>
            <param name="zones">Zones to rewrite</param>
            <param name="dataToWrite">Metadata to update the zones with</param>
            <param name="tagExists">True if the tag already exists on the current data stream; false if not</param>
            <param name="useBuffer">True if I/O has to be buffered. Makes I/O faster but consumes more RAM.</param>
            <returns>True if the operation succeeded; false if it something unexpected happened during the processing</returns>
        </member>
        <member name="M:ATL.AudioData.IO.FileSurgeon.computeZoneRegions(System.Collections.Generic.ICollection{ATL.AudioData.FileStructureHelper.Zone},System.Int64)">
            <summary>
            Build buffering Regions according to the given zones and total stream (usually file) size
            </summary>
            <param name="zones">Zones to calculate Regions from, ordered by their offset</param>
            <param name="streamSize">Total size of the corresponding file, in bytes</param>
            <returns>Buffering Regions containing the given zones</returns>
        </member>
        <member name="M:ATL.AudioData.IO.FileSurgeon.getLowestOffset(System.Collections.Generic.ICollection{ATL.AudioData.FileStructureHelper.Zone})">
            <summary>
            Get the lowest offset among the given zones
            Searches through zone offsets _and_ header offsets
            </summary>
            <param name="zones">Zones to examine</param>
            <returns>Lowest offset value among the given zones' zone offsets and header offsets</returns>
        </member>
        <member name="M:ATL.AudioData.IO.FileSurgeon.getLowestOffset(ATL.AudioData.FileStructureHelper.Zone)">
            <summary>
            Get the lowest offset among the given zone
            Searches through zone offsets _and_ header offsets
            </summary>
            <param name="zone">Zone to examine</param>
            <returns>Lowest offset value among the given zone's zone offsets and header offsets</returns>
        </member>
        <member name="M:ATL.AudioData.IO.FileSurgeon.getHighestOffset(System.Collections.Generic.ICollection{ATL.AudioData.FileStructureHelper.Zone})">
            <summary>
            Get the highest offset among the given zones
            Searches through zone offsets _and_ header offsets
            </summary>
            <param name="zones">Zones to examine</param>
            <returns>Highest offset value among the given zones' zone offsets and header offsets</returns>
        </member>
        <member name="M:ATL.AudioData.IO.FileSurgeon.getHighestOffset(ATL.AudioData.FileStructureHelper.Zone)">
            <summary>
            Get the highest offset among the given zone
            Searches through zone offsets _and_ header offsets
            </summary>
            <param name="zone">Zone to examine</param>
            <returns>Highest offset value among the given zone's zone offsets and header offsets</returns>
        </member>
        <member name="T:ATL.AudioData.WMAHelper">
            <summary>
            General utility class to manipulate WMA-like tags embedded in other formats (e.g. MP4)
            </summary>
        </member>
        <member name="M:ATL.AudioData.WMAHelper.ReadFields(System.IO.BinaryReader,System.Int64)">
            <summary>
            Read WMA-like formatted fields starting at the given reader's current position, and stopping after the given size
            </summary>
            <param name="source">Source to read the fields from</param>
            <param name="atomDataSize">Max size of the zone to read</param>
            <returns>List of the detected metadata fields</returns>
        </member>
        <member name="M:ATL.AudioData.WMAHelper.WriteField(System.IO.BinaryWriter,System.String,System.String,System.Boolean)">
            <summary>
            Write the given field with the given writer, using the WMA-like format
            </summary>
            <param name="w">Write to write the fields to</param>
            <param name="fieldName">Field name</param>
            <param name="fieldValue">Field value</param>
            <param name="isNumeric">True if the field is numeric; false if not (will be formatted as string)</param>
        </member>
        <member name="M:ATL.AudioData.WMAHelper.getAtlCodeForFrame(System.String)">
            <summary>
            Get the ATL field code from the given WMA field name
            </summary>
            <param name="frame">WMA field name</param>
            <returns>Matching ATL field code if found (See TagData.TAG_FIELD_XX properties); 255 if not</returns>
        </member>
        <member name="M:ATL.AudioData.WMAHelper.getValueFromTagData(System.String,ATL.TagData)">
            <summary>
            Return the value of the ATL field equivalent to the given WMA field that has been set in the given tag values
            Return an empty string if no equivalent field has been found
            </summary>
            <param name="frame">WMA field name of the field to find</param>
            <param name="tagData">Tag values to search into</param>
            <returns>Matching value taken from tagData; empty string if no match found</returns>
        </member>
        <member name="T:ATL.AudioData.MetaDataIOFactory">
            <summary>
            Factory for metadata (tag) I/O classes
            </summary>
        </member>
        <member name="F:ATL.AudioData.MetaDataIOFactory.TAG_ID3V1">
            <summary>
            ID3v1
            </summary>
        </member>
        <member name="F:ATL.AudioData.MetaDataIOFactory.TAG_ID3V2">
            <summary>
            ID3v2
            </summary>
        </member>
        <member name="F:ATL.AudioData.MetaDataIOFactory.TAG_APE">
            <summary>
            APEtag
            </summary>
        </member>
        <member name="F:ATL.AudioData.MetaDataIOFactory.TAG_NATIVE">
            <summary>
            Native tag format associated with the audio container (ex : MP4 built-in tagging format)
            </summary>
        </member>
        <member name="F:ATL.AudioData.MetaDataIOFactory.TAG_ANY">
            <summary>
            Whenever tag type is not known in advance and may apply to any available tag
            </summary>
        </member>
        <member name="F:ATL.AudioData.MetaDataIOFactory.TAG_TYPE_COUNT">
            <summary>
            Count of the types defined above, excluding "any" type
            </summary>
        </member>
        <member name="P:ATL.AudioData.MetaDataIOFactory.CrossReading">
            <summary>
            Sets whether the next created metadatareaders should use cross-tag reading
              - false           :  the most important tagging standard (according to priorities)
                                   detected on the track is exclusively used to populate fields
              - true (default)  :  for each field, the most important tagging standard (according to
                                   priorities) is first read. If the value is empty, the next
                                   tagging standard (according to priorities) is read, and so on...
            </summary>
        </member>
        <member name="M:ATL.AudioData.MetaDataIOFactory.GetInstance">
            <summary>
            Gets the instance of this factory (Singleton pattern) 
            </summary>
            <returns>Instance of the MetaReaderFactory of the application</returns>
        </member>
        <member name="M:ATL.AudioData.MetaDataIOFactory.SetTagPriority(System.Int32,System.Int32)">
            <summary>
            Modifies the default reading priority of the metadata
            </summary>
            <param name="tag">Identifier of the metadata type</param>
            <param name="rank">Reading priority (0..TAG_TYPE_COUNT-1)</param>
        </member>
        <member name="M:ATL.AudioData.MetaDataIOFactory.GetMetaReader(ATL.AudioData.AudioDataManager,System.Int32)">
            <summary>
            Gets the appropriate metadata reader for a given file / physical data reader
            </summary>
            <param name="theDataManager">AudioDataReader produced for this file</param>
            <param name="forceTagType">Forces a certain tag type to be read regardless of the current "cross reading" settings</param>
            <returns>Metadata reader able to give metadata info for this file (or the dummy reader if the format is unknown)</returns>
        </member>
        <member name="T:ATL.AudioData.FileStructureHelper">
            <summary>
            Helper class used to :
              - Record location and size of specific chunks of data within a structured file, called "Zones"
              - Record location, value and type of headers describing Zones
              - Modify these headers as Zones appear, disappear, expand or shrink
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.DEFAULT_ZONE_NAME">
            <summary>
            Default zone name to be used when no naming is necessary (simple cases where there is a but a single Zone to describe)
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.PADDING_ZONE_NAME">
            <summary>
            Zone name to be used for padding
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.POST_PROCESSING_ZONE_NAME">
            <summary>
            Zone name to be used to store post-processing elements
            </summary>
        </member>
        <member name="T:ATL.AudioData.FileStructureHelper.ACTION">
            <summary>
            Type of action to react to
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.ACTION.Edit">
            <summary>
            Existing zone is edited, and not removed
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.ACTION.Add">
            <summary>
            New zone is added
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.ACTION.Delete">
            <summary>
            Existing zone is removed
            </summary>
        </member>
        <member name="T:ATL.AudioData.FileStructureHelper.FrameHeader">
            <summary>
            Container class describing a frame header
            </summary>
        </member>
        <member name="T:ATL.AudioData.FileStructureHelper.FrameHeader.TYPE">
            <summary>
            Header types
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.TYPE.Counter">
            <summary>
            Counter : counts the underlying number of frames
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.TYPE.Size">
            <summary>
            Size : documents the size of a given frame / group of frames
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.TYPE.Index">
            <summary>
            Index (absolute) : documents the offset (position of 1st byte) of a given frame
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.TYPE.RelativeIndex">
            <summary>
            Index (relative) : documents the offset (position of 1st byte) of a given frame, relative to the header's position
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.Type">
            <summary>
            Header type (allowed values are TYPE_XXX within FrameHeader class)
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.Position">
            <summary>
            Position of the header
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.IsLittleEndian">
            <summary>
            True if header value is stored using little-endian convention; false if big-endian
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.ParentZone">
            <summary>
            Zone where the header is located physically
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.ValueZone">
            <summary>
            Zone to which the header value is pointing to (for post-processing only)
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.FrameHeader.Value">
            <summary>
            Current value of the header (counter : number of frames / size : frame size / index : frame index (absolute) / rindex : frame index (relative to header position))
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.FrameHeader.#ctor(ATL.AudioData.FileStructureHelper.FrameHeader.TYPE,System.Int64,System.Object,System.Boolean,System.String,System.String)">
            <summary>
            Constructs a new frame header using the given field values
            </summary>
        </member>
        <member name="T:ATL.AudioData.FileStructureHelper.Zone">
            <summary>
            Container class describing a chunk/frame within a structured file 
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.Name">
            <summary>
            Zone name (any unique value will do; used as internal reference only)
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.Offset">
            <summary>
            Offset in bytes
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.Size">
            <summary>
            Size in bytes
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.CoreSignature">
            <summary>
            Data sequence that has to be written in the zone when the zone does not contain any other data
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.IsDeletable">
            <summary>
            Indicates whether the zone contents are deletable by ATL (e.g. non-metadata zone is not deletable)
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.Flag">
            <summary>
            Generic usage flag for storing information
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.Headers">
            <summary>
            Size descriptors and item counters referencing the zone elsehwere on the file
            </summary>
        </member>
        <member name="F:ATL.AudioData.FileStructureHelper.Zone.IsResizable">
            <summary>
            True if the zone might shrink or enlarge, false if it must keep its original size
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.Zone.#ctor(System.String,System.Int64,System.Int32,System.Byte[],System.Boolean,System.Byte,System.Boolean)">
            <summary>
            Construct a new Zone using the given field values
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.Zone.Clear">
            <summary>
            Remove all headers
            </summary>
        </member>
        <member name="P:ATL.AudioData.FileStructureHelper.ZoneNames">
            <summary>
            Names of recorded zones
            </summary>
        </member>
        <member name="P:ATL.AudioData.FileStructureHelper.Zones">
            <summary>
            Recorded zones, sorted by offset
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.#ctor(System.Boolean)">
            <summary>
            Construct a new FileStructureHelper
            </summary>
            <param name="isLittleEndian">True if unerlying file uses little-endian convention for number representation; false if big-endian</param>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.Clear">
            <summary>
            Clear all recorded Zones
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.GetZone(System.String)">
            <summary>
            Retrieve a zone by its name
            </summary>
            <param name="name">Name of the zone to retrieve</param>
            <returns>The zone corresponding to the given name; null if not found</returns>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddZone(ATL.AudioData.FileStructureHelper.Zone)">
            <summary>
            Record a new zone by copying the given zone
            </summary>
            <param name="zone">Zone to be recorded</param>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddZone(System.Int64,System.Int32,System.String,System.Boolean,System.Boolean)">
            <summary>
            Record a new zone using the given fields
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddZone(System.Int64,System.Int32,System.Byte[],System.String,System.Boolean,System.Boolean)">
            <summary>
            Record a new zone using the given fields
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.RemoveZone(System.String)">
            <summary>
            Remove the zone identified with the given name
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddCounter(System.Int64,System.Object,System.String,System.String)">
            <summary>
            Record a new Counter-type header using the given fields and attach it to the zone of given name
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddSize(System.Int64,System.Object,System.String,System.String)">
            <summary>
            Record a new Size-type header using the given fields and attach it to the zone of given name
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddIndex(System.Int64,System.Object,System.Boolean,System.String,System.String)">
            <summary>
            Record a new Index-type header using the given fields and attach it to the zone of given name
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.AddPostProcessingIndex(System.Int64,System.Object,System.Boolean,System.String,System.String,System.String)">
            <summary>
            Record a new Index-type header using the given fields and attach it to the zone of given name, using a position relative to that zone's offset
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.DeclareZone(System.String)">
            <summary>
            Declare a zone in advance; useful when reading header frames of containing upper frames, without having reached tag frame itself
            </summary>
            <param name="zone"></param>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.addZoneHeader(System.String,ATL.AudioData.FileStructureHelper.FrameHeader.TYPE,System.Int64,System.Object,System.Boolean,System.String,System.String)">
            <summary>
            Record a new header using the given fields and attach it to the zone of given name
            </summary>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.updateAllHeadersAtPosition(System.Int64,System.Object)">
            <summary>
            Update all headers at the given position to the given value
            (useful when multiple zones refer to the very same header)
            </summary>
            <param name="position">Position of header to be updated</param>
            <param name="newValue">New value to be assigned to header</param>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.addToValue(System.Object,System.Int64,System.Object@)">
            <summary>
            Perform the addition between the two given values and encodes the result to an array of bytes, according to the type of the reference value
            </summary>
            <param name="value">Reference value</param>
            <param name="delta">Value to add</param>
            <param name="updatedValue">Updated value (out parameter; will be returned as same type as reference value)</param>
            <returns>Resulting value after the addition, encoded into an array of bytes, as the same type of the reference value</returns>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.getCorrectedOffset(System.String)">
            <summary>
            Return the the given zone's offset corrected according to the position shifts already applied by previous calls to <see cref="M:ATL.AudioData.FileStructureHelper.RewriteHeaders(System.IO.BinaryWriter,System.IO.BinaryWriter,System.Int64,ATL.AudioData.FileStructureHelper.ACTION,System.String,System.Int64,System.Int32)"/>
            e.g. if offset is 30 and 10 bytes have been inserted at position 15, corrected offset will be 40
            </summary>
            <param name="zone">Name of the zone to get the corrected offset for</param>
            <returns>Corrected offset of the zone with the given name</returns>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.getCorrectedOffset(System.Int64)">
            <summary>
            Return the the given offset corrected according to the position shifts already applied by previous calls to <see cref="M:ATL.AudioData.FileStructureHelper.RewriteHeaders(System.IO.BinaryWriter,System.IO.BinaryWriter,System.Int64,ATL.AudioData.FileStructureHelper.ACTION,System.String,System.Int64,System.Int32)"/>
            e.g. if offset is 30 and 10 bytes have been inserted at position 15, corrected offset will be 40
            </summary>
            <param name="offset">Offset to correct</param>
            <returns>Corrected offset</returns>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.PostProcessing(System.IO.BinaryWriter)">
            <summary>
            Perform post-processing modifications to the given stream
            </summary>
            <param name="writer">Stream to write modifications to</param>
        </member>
        <member name="M:ATL.AudioData.FileStructureHelper.RewriteHeaders(System.IO.BinaryWriter,System.IO.BinaryWriter,System.Int64,ATL.AudioData.FileStructureHelper.ACTION,System.String,System.Int64,System.Int32)">
            <summary>
            Rewrite all zone headers in the given stream according to the given size evolution and the given action
            </summary>
            <param name="fullScopeWriter">Full stream to write modifications to</param>
            <param name="bufferedWriter">Buffered stream to write modifications to</param>
            <param name="deltaSize">Evolution of zone size (in bytes; positive or negative)</param>
            <param name="action">Action applied to zone</param>
            <param name="zone">Name of zone to process</param>
            <param name="globalOffsetCorrection">Offset correction to apply to the zone to process</param>
            <param name="regionId">ID of the current buffer region; -1 if working on the file itself (global offset correction)</param>
            <returns></returns>
        </member>
        <member name="T:ATL.AudioData.TrackUtils">
            <summary>
            General utility class to manipulate values extracted from tracks metadata
            </summary>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.ExtractTrackNumber(System.String)">
            <summary>
            Extract the track number from the given string
            </summary>
            <param name="str">Raw "track" field in string form</param>
            <returns>Track number, in integer form; 0 if no track number has been found</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.ExtractTrackTotal(System.String)">
            <summary>
            Extract the total track number from the given string
            </summary>
            <param name="str">Raw "track" field in string form</param>
            <returns>Total track number, in integer form; 0 if no total track number has been found</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.DecodePopularity(System.String,System.Int32)">
            <summary>
            Extract rating level from the given string
            </summary>
            <param name="ratingString">Raw "rating" field in string form</param>
            <param name="convention">Tagging convention (see MetaDataIO.RC_XXX constants)</param>
            <returns>Rating level, in float form (0 = 0% to 1 = 100%)</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.DecodePopularity(System.Double,System.Int32)">
            <summary>
            Extract rating level from the given byte
            </summary>
            <param name="rating">Raw "rating" field in byte form</param>
            <param name="convention">Tagging convention (see MetaDataIO.RC_XXX constants)</param>
            <returns>Rating level, in float form (0 = 0% to 1 = 100%)</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.EncodePopularity(System.String,System.Int32)">
            <summary>
            Return the given popularity encoded with the given convention
            </summary>
            <param name="ratingStr">Popularity (note 0-5), represented in String form (e.g. "2.5")</param>
            <param name="convention">Convention type (See MetaDataIO.RC_XXX constants)</param>
            <returns>Popularity encoded with the given convention</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.EncodePopularity(System.Double,System.Int32)">
            <summary>
            Return the given popularity encoded with the given convention
            </summary>
            <param name="rating">Popularity (note 0-5)</param>
            <param name="convention">Convention type (See MetaDataIO.RC_XXX constants)</param>
            <returns>Popularity encoded with the given convention</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.ExtractIntYear(System.String)">
            <summary>
            Finds a year (4 consecutive numeric chars) in a string
            </summary>
            <param name="str">String to search the year into</param>
            <returns>Found year in integer form; 0 if no year has been found</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.ExtractStrYear(System.String)">
            <summary>
            Find a year (4 consecutive numeric chars) in a string
            </summary>
            <param name="str">String to search the year into</param>
            <returns>Found year in string form; "" if no year has been found</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.FormatWithLeadingZeroes(System.String,System.Boolean,System.Int32,System.Boolean,System.String)">
            <summary>
            Format the given track or disc number string according to the given parameters
                - If a single figure is given, result is a single figure
                - If two figures are given separated by "/" (e.g. "3/5"), result is both figures formatted and separated by "/"
            The number of digits and leading zeroes to use can be customized.
            </summary>
            <param name="value">Value to format; may contain separators. Examples of valid values : "1", "03/5", "4/005"...</param>
            <param name="overrideExistingFormat">If false, the given value will be formatted using <c>existingDigits</c></param>
            <param name="existingDigits">Target number of digits for each of the formatted values; 0 if no constraint</param>
            <param name="useLeadingZeroes">If true, and <c>overrideExistingFormat</c> is also true, the given value will be formatted using <c>total</c></param>
            <param name="total">Total number of tracks/albums to align the given value with while formatting. The length of the string will be used, not its value</param>
            <returns>Given track or disc number(s) formatted according to the given paramaters</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.formatWithLeadingZeroesInternal(System.String,System.Boolean,System.Int32,System.Boolean,System.String)">
            <summary>
            Format the given value according to the given parameters
            </summary>
            <param name="value">Value to format; should not contain separators</param>
            <param name="overrideExistingFormat">If false, the given value will be formatted using <c>existingDigits</c></param>
            <param name="existingDigits">Target number of digits for the formatted value; 0 if no constraint</param>
            <param name="useLeadingZeroes">If true, and <c>overrideExistingFormat</c> is also true, the given value will be formatted using <c>total</c></param>
            <param name="total">Total number of tracks/albums to align the given value with while formatting. The length of the string will be used, not its value</param>
            <returns>Given track or disc number(s) formatted according to the given paramaters</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.FormatISOTimestamp(System.DateTime)">
            <summary>
            Format the given DateTime to the most concise human-readable string
            Subsets of ISO 8601 will be used : yyyy, yyyy-MM, yyyy-MM-dd, yyyy-MM-ddTHH, yyyy-MM-ddTHH:mm, yyyy-MM-ddTHH:mm:ss
            </summary>
            <param name="dateTime">DateTime to format</param>
            <returns>Human-readable string representation of the given DateTime with relevant information only</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.FormatISOTimestamp(System.String,System.String,System.String)">
            <summary>
            Format the given elemnts to the most concise human-readable string
            Subsets of ISO 8601 will be used : yyyy, yyyy-MM, yyyy-MM-dd, yyyy-MM-ddTHH, yyyy-MM-ddTHH:mm, yyyy-MM-ddTHH:mm:ss
            </summary>
            <param name="year">Year</param>
            <param name="dayMonth">Day and month (DDMM format)</param>
            <param name="hoursMinutesSeconds">Time (hhmm format)</param>
            <returns>Human-readable string representation of the given DateTime with relevant information only</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.FormatISOTimestamp(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Format the given elemnts to the most concise human-readable string
            Subsets of ISO 8601 will be used : yyyy, yyyy-MM, yyyy-MM-dd, yyyy-MM-ddTHH, yyyy-MM-ddTHH:mm, yyyy-MM-ddTHH:mm:ss
            </summary>
            <param name="year">Year</param>
            <param name="day">Day</param>
            <param name="month">Month</param>
            <param name="hour">Hours</param>
            <param name="minutes">Minutes</param>
            <param name="seconds">Seconds</param>
            <returns>Human-readable string representation of the given DateTime with relevant information only</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.ComputePaddingSize(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Compute new size of the padding area according to the given parameters
            </summary>
            <param name="initialPaddingOffset">Initial offset of the padding zone</param>
            <param name="initialPaddingSize">Initial size of the padding zone</param>
            <param name="initialTagSize">Initial size of the tag area</param>
            <param name="currentTagSize">Current size of the tag area</param>
            <returns>New size to give to the padding area</returns>
        </member>
        <member name="M:ATL.AudioData.TrackUtils.ComputePaddingSize(System.Int64,System.Int64,System.Int64)">
            <summary>
            Compute new size of the padding area according to the given parameters
            </summary>
            <param name="initialPaddingOffset">Initial offset of the padding zone</param>
            <param name="initialPaddingSize">Initial size of the padding zone</param>
            <param name="deltaSize">Variation of padding zone size
                lower than 0 => Metadata size has increased => Padding should decrease
                higher than 0 => Metadata size has decreased => Padding should increase
            </param>
            <returns>New size to give to the padding area</returns>
        </member>
        <member name="T:ATL.OggCRC32">
            <summary>
            Class used to perform CRC calculations for OGG format
            </summary>
        </member>
        <member name="T:ATL.CatalogDataReaders.BinaryLogic.Cue">
            <summary>
            Class for cuesheet files reading (extension .cue)
            http://wiki.hydrogenaud.io/index.php?title=Cue_sheet
            </summary>
        </member>
        <member name="T:ATL.CatalogDataReaders.CatalogDataReaderFactory">
            <summary>
            Factory for Catalog data readers
            </summary>
        </member>
        <member name="T:ATL.CatalogDataReaders.ICatalogDataReader">
            <summary>
            Reads all tracks described in a container (e.g. : CUE sheet)
            </summary>
        </member>
        <member name="P:ATL.CatalogDataReaders.ICatalogDataReader.Path">
            <summary>
            Absolute path of the container file
            </summary>
        </member>
        <member name="P:ATL.CatalogDataReaders.ICatalogDataReader.Title">
            <summary>
            Title of the container
            </summary>
        </member>
        <member name="P:ATL.CatalogDataReaders.ICatalogDataReader.Artist">
            <summary>
            Artist of the container
            </summary>
        </member>
        <member name="P:ATL.CatalogDataReaders.ICatalogDataReader.Comments">
            <summary>
            Comments of the container
            </summary>
        </member>
        <member name="P:ATL.CatalogDataReaders.ICatalogDataReader.Tracks">
            <summary>
            List of the tracks described in the container
            </summary>
        </member>
        <member name="M:ATL.ChannelsArrangements.GuessFromChannelNumber(System.Int32)">
            <summary>
            Returns the most commonly used ISO ChannelsArrangement corresponding to the given number of channels
            </summary>
            <param name="nbChannels">Number of channels</param>
            <returns>Most commonly used ISO ChannelsArrangement corresponding to the given number of channels</returns>
        </member>
        <member name="T:ATL.ChannelsArrangements.ChannelsArrangement">
            <summary>
            Describes a specific arrangement of audio channels
            </summary>
        </member>
        <member name="P:ATL.ChannelsArrangements.ChannelsArrangement.Description">
            <summary>
            Description of the arrangement, in english
            </summary>
        </member>
        <member name="P:ATL.ChannelsArrangements.ChannelsArrangement.NbChannels">
            <summary>
            Number of channels involved
            </summary>
        </member>
        <member name="T:ATL.ChapterInfo">
            <summary>
            Information describing a chapter
            </summary>
        </member>
        <member name="T:ATL.ChapterInfo.UrlInfo">
            <summary>
            Information describing an URL
            </summary>
        </member>
        <member name="P:ATL.ChapterInfo.UrlInfo.Description">
            <summary>
            Description
            </summary>
        </member>
        <member name="P:ATL.ChapterInfo.UrlInfo.Url">
            <summary>
            The URL itself
            </summary>
        </member>
        <member name="M:ATL.ChapterInfo.UrlInfo.#ctor(ATL.ChapterInfo.UrlInfo)">
            <summary>
            Construct by copying data from the given UrlInfo
            </summary>
            <param name="url">Object to copy data from</param>
        </member>
        <member name="M:ATL.ChapterInfo.UrlInfo.#ctor(System.String,System.String)">
            <summary>
            Construct the structure from the URL and its description
            </summary>
            <param name="description">Description</param>
            <param name="url">The URL itself</param>
        </member>
        <member name="M:ATL.ChapterInfo.UrlInfo.#ctor(System.String)">
            <summary>
            Construct the structure from a single URL
            </summary>
            <param name="url">The URL itself</param>
        </member>
        <member name="M:ATL.ChapterInfo.UrlInfo.ToString">
            <summary>
            Internal string representation of the structure
            </summary>
            <returns>Internal string representation of the structure</returns>
        </member>
        <member name="P:ATL.ChapterInfo.StartTime">
            <summary>
            Start time (ms)
            NB : Only used when <see cref="P:ATL.ChapterInfo.UseOffset"/> is false
            </summary>
        </member>
        <member name="P:ATL.ChapterInfo.EndTime">
            <summary>
            End time (ms)
            NB : Only used when <see cref="P:ATL.ChapterInfo.UseOffset"/> is false
            </summary>
        </member>
        <member name="P:ATL.ChapterInfo.StartOffset">
            <summary>
            Start offset (bytes)
            NB1 : Only used when <see cref="P:ATL.ChapterInfo.UseOffset"/> is true
            NB2 : Only supported by ID3v2
            </summary>
        </member>
        <member name="P:ATL.ChapterInfo.EndOffset">
            <summary>
            End offset (bytes)
            NB1 : Only used when <see cref="P:ATL.ChapterInfo.UseOffset"/> is true
            NB2 : Only supported by ID3v2
            </summary>
        </member>
        <member name="P:ATL.ChapterInfo.UseOffset">
            <summary>
            True to use StartOffset / EndOffset instead of StartTime / EndTime
            NB : Only supported by ID3v2
            Default : false
            </summary>
        </member>
        <member name="P:ATL.ChapterInfo.Title">
            <summary>
            Title
            </summary>
        </member>
        <member name="P:ATL.ChapterInfo.UniqueID">
            <summary>
            Unique ID
            NB : Only supported by ID3v2
            </summary>
        </member>
        <member name="P:ATL.ChapterInfo.Subtitle">
            <summary>
            Subtitle
            NB : Only supported by ID3v2
            </summary>
        </member>
        <member name="P:ATL.ChapterInfo.Url">
            <summary>
            Associated URL
            NB : Only supported by ID3v2
            </summary>
        </member>
        <member name="P:ATL.ChapterInfo.Picture">
            <summary>
            Associated picture
            NB : Only supported by ID3v2
            </summary>
        </member>
        <member name="M:ATL.ChapterInfo.#ctor(System.UInt32,System.String)">
            <summary>
            Construct an empty structure
            </summary>
        </member>
        <member name="M:ATL.ChapterInfo.#ctor(ATL.ChapterInfo)">
            <summary>
            Construct a structure by copying informatio from the given ChapterInfo
            </summary>
            <param name="chapter">Structure to copy information from</param>
        </member>
        <member name="T:ATL.Format">
            <summary>
            Describes a file format
            </summary>
        </member>
        <member name="F:ATL.Format.mimeList">
            <summary>
            MIME types associated with the format
            </summary>
        </member>
        <member name="F:ATL.Format.extList">
            <summary>
            List of file extensions proper to this format
            </summary>
        </member>
        <member name="M:ATL.Format.#ctor(System.Int32,System.String,System.String)">
            <summary>
            Construct a format
            </summary>
            <param name="id">Unique ID</param>
            <param name="name">Name</param>
            <param name="shortName">Short name</param>
        </member>
        <member name="M:ATL.Format.#ctor(ATL.Format)">
            <summary>
            Construct a format by copying data from the given Format object
            </summary>
            <param name="f">Format to copy data from</param>
        </member>
        <member name="M:ATL.Format.copyFrom(ATL.Format)">
            <summary>
            Integrate data from the given Format object
            </summary>
            <param name="iFormat">Format to copy data from</param>
        </member>
        <member name="M:ATL.Format.init(System.Int32,System.String)">
            <summary>
            Initialize the object from its parts
            </summary>
            <param name="id">Unique ID</param>
            <param name="name">Name</param>
        </member>
        <member name="M:ATL.Format.init(System.Int32,System.String,System.String)">
            <summary>
            Initialize the object from its parts
            </summary>
            <param name="id">Unique ID</param>
            <param name="name">Name</param>
            <param name="shortName">Short name</param>
        </member>
        <member name="P:ATL.Format.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="P:ATL.Format.ShortName">
            <summary>
            Short name
            </summary>
        </member>
        <member name="P:ATL.Format.ID">
            <summary>
            Internal unique ID
            </summary>
        </member>
        <member name="P:ATL.Format.Readable">
            <summary>
            True if the format is readable by ATL
            </summary>
        </member>
        <member name="P:ATL.Format.MimeList">
            <summary>
            MIME types associated with the format
            </summary>
        </member>
        <member name="M:ATL.Format.AddMimeType(System.String)">
            <summary>
            Add the given MIME-type to the supported MIME-types of this Format
            </summary>
            <param name="mimeType">MIME-type to add</param>
        </member>
        <member name="M:ATL.Format.IsValidMimeType(System.String)">
            <summary>
            Test if the given MIME-type is associated with the current Format
            </summary>
            <param name="mimeType">MIME-type to test</param>
            <returns>True if the given MIME-type is associated with the current Format; false if not</returns>
        </member>
        <member name="M:ATL.Format.AddExtension(System.String)">
            <summary>
            Add the given extension to the supported extensions list
            </summary>
            <param name="ext">Extension to add to the supported extensions list (e.g. "bmp" for the Bitmap image format)</param>
        </member>
        <member name="M:ATL.Format.IsValidExtension(System.String)">
            <summary>
            Test if the given extension is a valid extension of the current Format
            </summary>
            <param name="ext">Extension to test (e.g. "bmp" for the Bitmap image format)</param>
            <returns>True if the given extension is a valid extension of the current Format; false if not</returns>
        </member>
        <member name="T:ATL.LyricsInfo">
            <summary>
            Information describing lyrics
            </summary>
        </member>
        <member name="T:ATL.LyricsInfo.LyricsType">
            <summary>
            Type (contents) of lyrics data
            NB : Directly inspired by ID3v2 format
            </summary>
        </member>
        <member name="F:ATL.LyricsInfo.LyricsType.OTHER">
            <summary>
            Other (i.e. none of the other types of this enum)
            </summary>
        </member>
        <member name="F:ATL.LyricsInfo.LyricsType.LYRICS">
            <summary>
            Lyrical data
            </summary>
        </member>
        <member name="F:ATL.LyricsInfo.LyricsType.TRANSCRIPTION">
            <summary>
            Transcription
            </summary>
        </member>
        <member name="F:ATL.LyricsInfo.LyricsType.MOVEMENT_NAME">
            <summary>
            List of the movements in the piece
            </summary>
        </member>
        <member name="F:ATL.LyricsInfo.LyricsType.EVENT">
            <summary>
            Events that occur
            </summary>
        </member>
        <member name="F:ATL.LyricsInfo.LyricsType.CHORD">
            <summary>
            Chord changes that occur in the music
            </summary>
        </member>
        <member name="F:ATL.LyricsInfo.LyricsType.TRIVIA">
            <summary>
            Trivia or "pop up" information about the media
            </summary>
        </member>
        <member name="F:ATL.LyricsInfo.LyricsType.WEBPAGE_URL">
            <summary>
            URLs for relevant webpages
            </summary>
        </member>
        <member name="F:ATL.LyricsInfo.LyricsType.IMAGE_URL">
            <summary>
            URLs for relevant images
            </summary>
        </member>
        <member name="T:ATL.LyricsInfo.LyricsPhrase">
            <summary>
            Phrase ("line") inside lyrics
            </summary>
        </member>
        <member name="P:ATL.LyricsInfo.LyricsPhrase.TimestampMs">
            <summary>
            Timestamp of the phrase, in milliseconds
            </summary>
        </member>
        <member name="P:ATL.LyricsInfo.LyricsPhrase.Text">
            <summary>
            Text
            </summary>
        </member>
        <member name="M:ATL.LyricsInfo.LyricsPhrase.#ctor(System.Int32,System.String)">
            <summary>
            Construct a lyrics phrase from its parts
            </summary>
            <param name="timestampMs">Timestamp, in milliseconds</param>
            <param name="text">Text</param>
        </member>
        <member name="M:ATL.LyricsInfo.LyricsPhrase.#ctor(System.String,System.String)">
            <summary>
            Construct a lyrics phrase from its parts
            </summary>
            <param name="timestamp">Timestamp, in the form of a timecode
            Supported formats : hh:mm, hh:mm:ss.ddd, mm:ss, hh:mm:ss and mm:ss.ddd</param>
            <param name="text">Text</param>
        </member>
        <member name="P:ATL.LyricsInfo.ContentType">
            <summary>
            Type
            </summary>
        </member>
        <member name="P:ATL.LyricsInfo.Description">
            <summary>
            Description
            </summary>
        </member>
        <member name="P:ATL.LyricsInfo.LanguageCode">
            <summary>
            Language code
            </summary>
        </member>
        <member name="P:ATL.LyricsInfo.UnsynchronizedLyrics">
            <summary>
            Data of unsynhronized (i.e. without associated timestamp) lyrics
            </summary>
        </member>
        <member name="P:ATL.LyricsInfo.SynchronizedLyrics">
            <summary>
            Data of unsynhronized (i.e. with associated timestamps) lyrics
            </summary>
        </member>
        <member name="M:ATL.LyricsInfo.#ctor">
            <summary>
            Construct empty lyrics information
            </summary>
        </member>
        <member name="M:ATL.LyricsInfo.#ctor(ATL.LyricsInfo)">
            <summary>
            Construct lyrics information by copying data from the given LyricsInfo object
            </summary>
            <param name="info">Object to copy data from</param>
        </member>
        <member name="T:ATL.MetaFieldInfo">
            <summary>
            Information describing a metadata field
            </summary>
        </member>
        <member name="T:ATL.MetaFieldInfo.ORIGIN">
            <summary>
            Origin of the field
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.ORIGIN.Unknown">
            <summary>
            Not valued
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.ORIGIN.Standard">
            <summary>
            Standard field mapped in ATL
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.ORIGIN.UnmappedStandard">
            <summary>
            Standard field unmapped in ATL (e.g. ID3v2 "Mood" field TMOO)
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.ORIGIN.Comment">
            <summary>
            Comment field with extended property parsed as field code (e.g. ID3v2 COMM)
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.ORIGIN.CustomStandard">
            <summary>
            Custom field through standard "custom" field (e.g. ID3v2 TXXX)
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.ORIGIN.Custom">
            <summary>
            Custom non-standard field (i.e. any other fancy value written regardless of standard)
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.TagType">
            <summary>
            Tag type where the picture originates from (see <see cref="T:ATL.AudioData.MetaDataIOFactory"/> static fields)
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.NativeFieldCode">
            <summary>
            Native field code according to TagType convention
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.StreamNumber">
            <summary>
            Index of the stream the field is attached to (if applicable, i.e. for multi-stream files)
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.Language">
            <summary>
            Language the value is written in
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.Value">
            <summary>
            Value of the field
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.Zone">
            <summary>
            File zone where the value is supposed to appear (ASF format I'm looking at you...)
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.Origin">
            <summary>
            Origin of the field
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.SpecificData">
            <summary>
            Attached data specific to the native format (e.g. AIFx Timestamp and Marker ID)
            </summary>
        </member>
        <member name="F:ATL.MetaFieldInfo.MarkedForDeletion">
            <summary>
            True if the field has to be deleted during the next call to <see cref="M:ATL.AudioData.IMetaDataIO.Write(System.IO.BinaryReader,System.IO.BinaryWriter,ATL.TagData,System.IProgress{System.Single})"/>
            </summary>
        </member>
        <member name="M:ATL.MetaFieldInfo.#ctor(System.Int32,System.String,System.String,System.UInt16,System.String,System.String)">
            <summary>
            Construct the structure from its parts
            </summary>
            <param name="tagType">Tag type where the picture originates from (see <see cref="T:ATL.AudioData.MetaDataIOFactory"/> static fields)</param>
            <param name="nativeFieldCode">Native field code according to TagType convention</param>
            <param name="value">Value of the field</param>
            <param name="streamNumber">Index of the stream the field is attached to (if applicable, i.e. for multi-stream files)</param>
            <param name="language">Language the value is written in</param>
            <param name="zone">File zone where the value is supposed to appear</param>
        </member>
        <member name="M:ATL.MetaFieldInfo.#ctor(ATL.MetaFieldInfo)">
            <summary>
            Construct the structure by copying data from the given MetaFieldInfo object
            </summary>
            <param name="info">Object to copy data from</param>
        </member>
        <member name="M:ATL.MetaFieldInfo.ToStringWithoutZone">
            <summary>
            Return the string representation of the object without taking its zone into account
            </summary>
            <returns>String representation of the object that doesn't take its zone into account</returns>
        </member>
        <member name="M:ATL.MetaFieldInfo.ToString">
            <summary>
            Return the string representation of the object
            </summary>
            <returns>String representation of the object</returns>
        </member>
        <member name="M:ATL.MetaFieldInfo.GetHashCode">
            <summary>
            Return the hash of the object
            </summary>
            <returns>Hash of the object</returns>
        </member>
        <member name="M:ATL.MetaFieldInfo.EqualsWithoutZone(System.Object)">
            <summary>
            Compare with the given object without taking zones into account
            </summary>
            <param name="obj">Object to compare with</param>
            <returns>Result of the comparison as per Equals convention, without taking zones into account</returns>
        </member>
        <member name="M:ATL.MetaFieldInfo.EqualsApproximate(ATL.MetaFieldInfo)">
            <summary>
            Compare with the given object using certain fields only (native field code, stream number, language)
            </summary>
            <param name="obj">Object to compare with</param>
            <returns>Result of the comparison as per Equals convention</returns>
        </member>
        <member name="M:ATL.MetaFieldInfo.Equals(System.Object)">
            <summary>
            Compare with the given object
            </summary>
            <param name="obj">Object to compare with</param>
            <returns>Result of the comparison as per Equals convention</returns>
        </member>
        <member name="T:ATL.PictureInfo">
            <summary>
            Information about an embedded picture
            </summary>
        </member>
        <member name="T:ATL.PictureInfo.PIC_TYPE">
            <summary>
            Type of the embedded picture
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.PIC_TYPE.Unsupported">
            <summary>
            Unsupported (i.e. none of the supported values in the enum)
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.PIC_TYPE.Generic">
            <summary>
            Generic
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.PIC_TYPE.Front">
            <summary>
            Front cover
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.PIC_TYPE.Back">
            <summary>
            Back cover
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.PIC_TYPE.CD">
            <summary>
            Picture of disc
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.PicType">
            <summary>
            Normalized picture type (see enum)
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.NativeFormat">
            <summary>
            Native image format
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.Position">
            <summary>
            Position of the picture among pictures of the same generic type / native code (default 1 if the picture is one of its kind)
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.TagType">
            <summary>
            Tag type where the picture originates from (see MetaDataIOFactory)
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.NativePicCode">
            <summary>
            Native picture code according to TagType convention (numeric : e.g. ID3v2)
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.NativePicCodeStr">
            <summary>
            Native picture code according to TagType convention (string : e.g. APEtag)
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.Description">
            <summary>
            Picture description
            </summary>
        </member>
        <member name="P:ATL.PictureInfo.PictureData">
            <summary>
            Binary picture data
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.PictureHash">
            <summary>
            Hash of binary picture data
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.MarkedForDeletion">
            <summary>
            True if the field has to be deleted in the next IMetaDataIO.Write operation
            </summary>
        </member>
        <member name="F:ATL.PictureInfo.TransientFlag">
            <summary>
            Freeform transient value to be used by other parts of the library
            </summary>
        </member>
        <member name="P:ATL.PictureInfo.MimeType">
            <summary>
            Get the MIME-type associated with the picture
            </summary>
        </member>
        <member name="M:ATL.PictureInfo.fromBinaryData(System.Byte[],ATL.PictureInfo.PIC_TYPE,System.Int32,System.Object,System.Int32)">
            <summary>
            Construct picture information from its raw, binary data
            </summary>
            <param name="data">Raw picture data</param>
            <param name="picType">Type of the picture (default : Generic)</param>
            <param name="tagType">Type of the containing tag (see static fields in <see cref="T:ATL.AudioData.MetaDataIOFactory"/>(default : TAG_ANY)</param>
            <param name="nativePicCode">Native code of the picture, as stated in its containing format's specs (default : not set)</param>
            <param name="position">Position of the picture among the other pictures of the same file (default : 1)</param>
            <returns></returns>
        </member>
        <member name="M:ATL.PictureInfo.fromBinaryData(System.IO.Stream,System.Int32,ATL.PictureInfo.PIC_TYPE,System.Int32,System.Object,System.Int32)">
            <summary>
            Construct picture information from its raw, binary data
            </summary>
            <param name="stream">Stream containing raw picture data, positioned at the beginning of picture data</param>
            <param name="length">Length of the picture data to read inside the given stream</param>
            <param name="picType">Type of the picture (default : Generic)</param>
            <param name="tagType">Type of the containing tag (see static fields in <see cref="T:ATL.AudioData.MetaDataIOFactory"/>(default : TAG_ANY)</param>
            <param name="nativePicCode">Native code of the picture, as stated in its containing format's specs (default : not set)</param>
            <param name="position">Position of the picture among the other pictures of the same file (default : 1)</param>
            <returns></returns>
        </member>
        <member name="M:ATL.PictureInfo.#ctor(ATL.PictureInfo,System.Boolean)">
            <summary>
            Construct picture information by copying data from another PictureInfo object
            </summary>
            <param name="picInfo">PictureInfo object to copy data from</param>
            <param name="copyPictureData">If true, copy raw picture data; if false only copy properties</param>
        </member>
        <member name="M:ATL.PictureInfo.#ctor(ATL.PictureInfo.PIC_TYPE,System.Int32,System.Object,System.Int32,System.Byte[])">
            <summary>
            Construct picture information from its parts
            </summary>
            <param name="picType">Type of the picture</param>
            <param name="tagType">Type of the containing tag (see static fields in <see cref="T:ATL.AudioData.MetaDataIOFactory"/></param>
            <param name="nativePicCode">Native code of the picture, as stated in its containing format's specs</param>
            <param name="position">Position of the picture among the other pictures of the same file</param>
            <param name="binaryData">Raw binary data of the picture</param>
        </member>
        <member name="M:ATL.PictureInfo.#ctor(ATL.PictureInfo.PIC_TYPE,System.Int32)">
            <summary>
            Construct picture information from its parts
            </summary>
            <param name="picType">Type of the picture</param>
            <param name="position">Position of the picture among the other pictures of the same file (default : 1)</param>
        </member>
        <member name="M:ATL.PictureInfo.#ctor(System.Int32,System.Object,System.Int32)">
            <summary>
            Construct picture information from its parts
            </summary>
            <param name="tagType">Type of the containing tag (see static fields in <see cref="T:ATL.AudioData.MetaDataIOFactory"/></param>
            <param name="nativePicCode">Native code of the picture, as stated in its containing format's specs</param>
            <param name="position">Position of the picture among the other pictures of the same file (default : 1)</param>
        </member>
        <member name="M:ATL.PictureInfo.ComputePicHash">
            <summary>
            Calculate the hash of the raw, binary data of this picture, using FNV-1a
            </summary>
            <returns>FNV-1a hash of the raw binary data</returns>
        </member>
        <member name="M:ATL.PictureInfo.ToString">
            <summary>
            Return the string representation of the object
            </summary>
            <returns>String representation of the object</returns>
        </member>
        <member name="M:ATL.PictureInfo.GetHashCode">
            <summary>
            Return the hash of the object
            </summary>
            <returns>Hash of the object</returns>
        </member>
        <member name="M:ATL.PictureInfo.Equals(System.Object)">
            <summary>
            Equals override
            </summary>
            <param name="obj">Object to test comparison with</param>
            <returns>Result of the comparison</returns>
        </member>
        <member name="T:ATL.TagData">
            <summary>
            Basic metadata fields container
            
            TagData aims at staying a basic, universal container, without any Property accessor layer nor any field interpretation logic
            </summary>
        </member>
        <member name="F:ATL.TagData.Chapters">
            <summary>
            Chapters 
            NB : The whole chapter list is processed as a whole
            </summary>
        </member>
        <member name="F:ATL.TagData.Lyrics">
            <summary>
            Lyrics
            </summary>
        </member>
        <member name="F:ATL.TagData.Pictures">
            <summary>
            Embedded pictures
            NB : Each entry is processed as a metadata field on its own
            </summary>
        </member>
        <member name="F:ATL.TagData.AdditionalFields">
            <summary>
            Additional fields = non-classic fields
            NB : Each entry is processed as a metadata field on its own
            </summary>
        </member>
        <member name="F:ATL.TagData.TrackDigitsForLeadingZeroes">
            <summary>
            > 0 if Track field is formatted with leading zeroes over X digits
            </summary>
        </member>
        <member name="F:ATL.TagData.DiscDigitsForLeadingZeroes">
            <summary>
            > 0 if Disc field is formatted with leading zeroes over X digits
            </summary>
        </member>
        <member name="F:ATL.TagData.DataSizeDelta">
            <summary>
            Current difference between written data size vs. initial data size
            Used to calculate padding size variation when FileStructureHelper is unavailable
            TODO - this is ugly, remove that when FLAC has been redesigned to use a FileStructureHelper
            </summary>
        </member>
        <member name="F:ATL.TagData.PaddingSize">
            <summary>
            Size of padding area, if any (target size of padding area, if used as input)
            </summary>
        </member>
        <member name="F:ATL.TagData.DurationMs">
            <summary>
            Duration of audio track, in milliseconds
            </summary>
        </member>
        <member name="M:ATL.TagData.#ctor">
            <summary>
            Construct an empty TagData
            </summary>
        </member>
        <member name="M:ATL.TagData.#ctor(ATL.TagData)">
            <summary>
            Construct a TagData by copying the properties of the given TagData
            </summary>
            <param name="tagData">TagData to copy properties from</param>
        </member>
        <member name="M:ATL.TagData.IntegrateValue(System.Byte,System.String)">
            <summary>
            Stores a 'classic' metadata value into current TagData object according to its key
            
            NB : This method cannot be used to store non-classic fields; use tagData.AdditionalFields instead
            </summary>
            <param name="key">Identifier describing the metadata to store (see TagData public consts)</param>
            <param name="value">Value of the metadata to store</param>
        </member>
        <member name="M:ATL.TagData.IntegrateValues(ATL.TagData,System.Boolean,System.Boolean)">
            <summary>
            Merge given TagData object with current TagData object
            </summary>
            <param name="data">TagData object to merge</param>
            <param name="integratePictures">Set to true to merge picture information (default : true)</param>
            <param name="mergeAdditionalData">Set to true to merge additional (i.e. non-TagData) fields (default : true)</param>
        </member>
        <member name="M:ATL.TagData.hasKey(System.Byte)">
            <summary>
            Indicate whether the current TagData stores a value for the given ATL field code
            </summary>
            <param name="id">Field code to search for</param>
            <returns>True if the current TagData stores a value for the given ATL field code; false if not</returns>
        </member>
        <member name="M:ATL.TagData.ToMap">
            <summary>
            Convert non-null 'classic' fields values into a properties Map
            
            NB : Additional fields, pictures and chapters won't be part of the Map
            </summary>
            <returns>Map containing all 'classic' metadata fields</returns>
        </member>
        <member name="M:ATL.TagData.Clear">
            <summary>
            Clear all values stored in TagData object
            </summary>
        </member>
        <member name="M:ATL.TagData.Cleanup">
            <summary>
            Cleanup field values that need to be reformatted : track and disc numbers, chapter data
            </summary>
        </member>
        <member name="M:ATL.TagData.addIfConsistent(System.String,System.Byte,System.Collections.Generic.IDictionary{System.Byte,System.String})">
            <summary>
            Add given value to given map if value is not null
            </summary>
            <param name="data">Value to add to the map</param>
            <param name="id">Key to add to the map</param>
            <param name="map">Target map to host given values</param>
        </member>
        <member name="M:ATL.TagData.emptyIfZero(System.String)">
            <summary>
            Convert given value to empty string ("") if null or zero ("0")
            </summary>
            <param name="s">Value to convert</param>
            <returns>If null or zero ("0"), empty string (""); else initial value</returns>
        </member>
        <member name="M:ATL.TagData.generatePicturePositions">
            <summary>
            Build a map containing the position of each picture in the Pictures field, based on the PictureInfo.Position fields
            
            NB : This method does not calculate any position; it just generates the map
            </summary>
            <returns>Map containing the position for each picture</returns>
        </member>
        <member name="T:ATL.Track">
            <summary>
            High-level class for audio file manipulation
            </summary>
        </member>
        <member name="M:ATL.Track.#ctor">
            <summary>
            Basic constructor; does nothing else than instanciating the Track object
            </summary>
        </member>
        <member name="M:ATL.Track.#ctor(System.String,System.IProgress{System.Single},System.Boolean)">
            <summary>
            Loads the file at the given path
            Only works with local paths; http, ftp and the like do not work.
            </summary>
            <param name="path">Path of the local file to be loaded</param>
            <param name="writeProgress">Callback that will be called multiple times when saving changes, as saving progresses (default : null = no callback)</param>
            <param name="load">True to load the file when running this constructor (default : true)</param>
        </member>
        <member name="M:ATL.Track.#ctor(System.String,System.Boolean)">
            <summary>
            Loads the file at the given path
            Only works with local paths; http, ftp and the like do not work.
            </summary>
            <param name="path">Path of the local file to be loaded</param>
            <param name="load">True to load the file when running this constructor (default : true)</param>
        </member>
        <member name="M:ATL.Track.#ctor(System.IO.Stream,System.String,System.IProgress{System.Single})">
            <summary>
            Loads the raw data in the given stream according to the given MIME-type
            </summary>
            <param name="stream">Stream containing the raw data to be loaded</param>
            <param name="mimeType">MIME-type (e.g. "audio/mp3") or file extension (e.g. ".mp3") of the content</param>
            <param name="writeProgress">Callback that will be called multiple times when saving changes, as saving progresses (default : null = no callback)</param>
        </member>
        <member name="F:ATL.Track.Path">
            <summary>
            Full path of the underlying file
            </summary>
        </member>
        <member name="P:ATL.Track.Title">
            <summary>
            Title
            </summary>
        </member>
        <member name="P:ATL.Track.Artist">
            <summary>
            Artist
            </summary>
        </member>
        <member name="P:ATL.Track.Composer">
            <summary>
            Composer
            </summary>
        </member>
        <member name="P:ATL.Track.Comment">
            <summary>
            Comments
            </summary>
        </member>
        <member name="P:ATL.Track.Genre">
            <summary>
            Genre
            </summary>
        </member>
        <member name="P:ATL.Track.Album">
            <summary>
            Title of the album
            </summary>
        </member>
        <member name="P:ATL.Track.OriginalAlbum">
            <summary>
            Title of the original album
            </summary>
        </member>
        <member name="P:ATL.Track.OriginalArtist">
            <summary>
            Original artist
            </summary>
        </member>
        <member name="P:ATL.Track.Copyright">
            <summary>
            Copyright
            </summary>
        </member>
        <member name="P:ATL.Track.Description">
            <summary>
            General description
            </summary>
        </member>
        <member name="P:ATL.Track.Publisher">
            <summary>
            Publisher
            </summary>
        </member>
        <member name="P:ATL.Track.PublishingDate">
            <summary>
            Publishing date
            </summary>
        </member>
        <member name="P:ATL.Track.AlbumArtist">
            <summary>
            Album Artist
            </summary>
        </member>
        <member name="P:ATL.Track.Conductor">
            <summary>
            Conductor
            </summary>
        </member>
        <member name="P:ATL.Track.Date">
            <summary>
            Recording Date
            </summary>
        </member>
        <member name="P:ATL.Track.Year">
            <summary>
            Recording Year
            </summary>
        </member>
        <member name="P:ATL.Track.TrackNumber">
            <summary>
            Track number
            </summary>
        </member>
        <member name="P:ATL.Track.TrackTotal">
            <summary>
            Total track number
            </summary>
        </member>
        <member name="P:ATL.Track.DiscNumber">
            <summary>
            Disc number
            </summary>
        </member>
        <member name="P:ATL.Track.DiscTotal">
            <summary>
            Total disc number
            </summary>
        </member>
        <member name="P:ATL.Track.Popularity">
            <summary>
            Popularity (0% = 0 stars to 100% = 5 stars)
            e.g. 3.5 stars = 70%
            </summary>
        </member>
        <member name="P:ATL.Track.PictureTokens">
            <summary>
            List of picture IDs stored in the tag
                PictureInfo.PIC_TYPE : internal, normalized picture type
                PictureInfo.NativePicCode : native picture code (useful when exploiting the UNSUPPORTED picture type)
                NB : PictureInfo.PictureData (raw binary picture data) is _not_ valued here; see EmbeddedPictures field
            </summary>
        </member>
        <member name="P:ATL.Track.ChaptersTableDescription">
            <summary>
            Chapters table of content description
            </summary>
        </member>
        <member name="P:ATL.Track.Chapters">
            <summary>
            Contains any other metadata field that is not represented by a getter in the above interface
            </summary>
        </member>
        <member name="P:ATL.Track.Lyrics">
            <summary>
            Synchronized and unsynchronized lyrics
            </summary>
        </member>
        <member name="P:ATL.Track.Bitrate">
            <summary>
            Bitrate (kilobytes per second)
            </summary>
        </member>
        <member name="P:ATL.Track.SampleRate">
            <summary>
            Sample rate (Hz)
            </summary>
        </member>
        <member name="P:ATL.Track.IsVBR">
            <summary>
            Returns true if the bitrate is variable; false if not
            </summary>
        </member>
        <member name="P:ATL.Track.CodecFamily">
            <summary>
            Family of the audio codec (See AudioDataIOFactory)
            0=Streamed, lossy data
            1=Streamed, lossless data
            2=Sequenced with embedded sound library
            3=Sequenced with codec or hardware-dependent sound library
            </summary>
        </member>
        <member name="P:ATL.Track.AudioFormat">
            <summary>
            Format of the audio data
            </summary>
        </member>
        <member name="P:ATL.Track.MetadataFormats">
            <summary>
            Format of the tagging systems
            </summary>
        </member>
        <member name="P:ATL.Track.Duration">
            <summary>
            Duration (seconds)
            </summary>
        </member>
        <member name="P:ATL.Track.DurationMs">
            <summary>
            Duration (milliseconds)
            </summary>
        </member>
        <member name="P:ATL.Track.ChannelsArrangement">
            <summary>
            Channels arrangement
            </summary>
        </member>
        <member name="P:ATL.Track.AdditionalFields">
            <summary>
            Contains any other metadata field that is not represented by a getter in the above interface
            </summary>
        </member>
        <member name="P:ATL.Track.EmbeddedPictures">
            <summary>
            List of pictures stored in the tag
            NB1 : PictureInfo.PictureData (raw binary picture data) is valued
            NB2 : Also allows to value embedded pictures inside chapters
            </summary>
        </member>
        <member name="F:ATL.Track.stream">
            <summary>
            Stream used to access in-memory Track contents (alternative to path, which is used to access on-disk Track contents)
            </summary>
        </member>
        <member name="F:ATL.Track.mimeType">
            <summary>
            MIME-type that describes in-memory Track contents (used in conjunction with stream)
            </summary>
        </member>
        <member name="M:ATL.Track.Save">
            <summary>
            Save current Track to disk
            </summary>
        </member>
        <member name="M:ATL.Track.Remove(System.Int32)">
            <summary>
            Remove the given tag type from the Track
            </summary>
            <param name="tagType">Tag type to remove (see MetaDataIOFactory.TAG_XX values)</param>
            <see cref="T:ATL.AudioData.MetaDataIOFactory"/>
        </member>
        <member name="T:ATL.Factory">
            <summary>
            Abstract factory for data readers, containing shared methods and members
            </summary>
        </member>
        <member name="F:ATL.Factory.UNKNOWN_FORMAT">
            <summary>
            Represents an unknown generic format
            </summary>
        </member>
        <member name="F:ATL.Factory.formatListByExt">
            <summary>
            List of all formats supported by this kind of data reader
            They are indexed by file extension to speed up matching
            </summary>
        </member>
        <member name="F:ATL.Factory.formatListByMime">
            <summary>
            List of all formats supported by this kind of data reader 
            They are indexed by MIME-type to speed up matching
            </summary>
        </member>
        <member name="M:ATL.Factory.addFormat(ATL.Format)">
            <summary>
            Adds a format to the supported formats
            </summary>
            <param name="f">Format to be added</param>
        </member>
        <member name="M:ATL.Factory.getFormatsFromPath(System.String)">
            <summary>
            Gets the valid formats from the given file path, using the file extension as key
            </summary>
            <param name="path">Path of the file which format to recognize</param>
            <returns>List of the valid formats matching the extension of the given file, 
            or null if none recognized or the file does not exist</returns>
        </member>
        <member name="M:ATL.Factory.getFormatsFromMimeType(System.String)">
            <summary>
            Gets the valid formats from the given MIME-type
            </summary>
            <param name="mimeType">MIME-type to recognize</param>
            <returns>List of the valid formats matching the MIME-type of the given file, 
            or null if none recognized</returns>
        </member>
        <member name="M:ATL.Factory.getFormats">
            <summary>
            Gets a list of all supported formats
            </summary>
            <returns>List of all supported formats</returns>
        </member>
        <member name="T:ATL.Logging.ILogDevice">
            <summary>
            This interface describes a logical device able to log messages
            </summary>
        </member>
        <member name="M:ATL.Logging.ILogDevice.DoLog(ATL.Logging.Log.LogItem)">
            <summary>
            Logs the message described by the provided LogItem object
            </summary>
            <param name="anItem">Data concerning the message to be logged</param>
        </member>
        <member name="T:ATL.Logging.Log">
            <summary>
            This class handles the logging of the application's messages
            </summary>
        </member>
        <member name="F:ATL.Logging.Log.LV_DEBUG">
            <summary>
            Debug logging level
            </summary>
        </member>
        <member name="F:ATL.Logging.Log.LV_INFO">
            <summary>
            Info logging level
            </summary>
        </member>
        <member name="F:ATL.Logging.Log.LV_WARNING">
            <summary>
            Warning logging level
            </summary>
        </member>
        <member name="F:ATL.Logging.Log.LV_ERROR">
            <summary>
            Error logging level
            </summary>
        </member>
        <member name="T:ATL.Logging.Log.LogItem">
            <summary>
            Definition of a message ("a line of the log")  
            </summary>
        </member>
        <member name="F:ATL.Logging.Log.LogItem.When">
            <summary>
            Date of the message
            </summary>
        </member>
        <member name="F:ATL.Logging.Log.LogItem.Level">
            <summary>
            Logging level
            </summary>
        </member>
        <member name="F:ATL.Logging.Log.LogItem.Location">
            <summary>
            Location of the message (e.g. filename, line, module...)
            </summary>
        </member>
        <member name="F:ATL.Logging.Log.LogItem.Message">
            <summary>
            Contents of the message
            </summary>
        </member>
        <member name="M:ATL.Logging.Log.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ATL.Logging.Log.Debug(System.String)">
            <summary>
            Log the provided message with the LV_DEBUG logging level
            </summary>
            <param name="msg">Contents of the message</param>
        </member>
        <member name="M:ATL.Logging.Log.Info(System.String)">
            <summary>
            Log the provided message with the LV_INFO logging level
            </summary>
            <param name="msg">Contents of the message</param>
        </member>
        <member name="M:ATL.Logging.Log.Warning(System.String)">
            <summary>
            Log the provided message with the LV_WARNING logging level
            </summary>
            <param name="msg">Contents of the message</param>
        </member>
        <member name="M:ATL.Logging.Log.Error(System.String)">
            <summary>
            Log the provided message with the LV_ERROR logging level
            </summary>
            <param name="msg">Contents of the message</param>
        </member>
        <member name="M:ATL.Logging.Log.SetLocation(System.String)">
            <summary>
            Set current location
            
            NB : Implementation is based on current thread ID, 
            so that Log object can be accessed by multiple threads,
            each setting its own location
            </summary>
            <param name="location">Location value</param>
        </member>
        <member name="M:ATL.Logging.Log.Write(System.Int32,System.String)">
            <summary>
            Log the provided message with the provided logging level
            </summary>
            <param name="level">Logging level of the new message</param>
            <param name="msg">Contents of the new message</param>
        </member>
        <member name="M:ATL.Logging.Log.doWrite(ATL.Logging.Log.LogItem,System.Boolean)">
            <summary>
            Log the provided message with the provided logging level
            </summary>
            <param name="theItem">Message to log</param>
            <param name="forceDisplay">If true, forces all registered ILogDevices to immediately log the message, even if asynchoronous logging is enabled</param>
        </member>
        <member name="M:ATL.Logging.Log.ClearAll">
            <summary>
            Clear the whole list of logged items
            </summary>
        </member>
        <member name="M:ATL.Logging.Log.GetAllItems">
            <summary>
            Get all the logged items 
            </summary>
            <returns>List of all the logged items</returns>
        </member>
        <member name="M:ATL.Logging.Log.GetAllItems(System.Int32)">
            <summary>
            Get the logged items whose logging level matches the provided mask 
            </summary>
            <param name="levelMask">Logging level mask</param>
            <returns>List of the matching logged items</returns>
        </member>
        <member name="M:ATL.Logging.Log.Register(ATL.Logging.ILogDevice)">
            <summary>
            Register a LogDevice
            A registered LogDevice will be called each time a new LogItem is received
            (see Write method) 
            </summary>
            <param name="aLogger">Device to register</param>
        </member>
        <member name="M:ATL.Logging.Log.SwitchAsync">
            <summary>
            Mark logging as asynchronous : no call will be made
            to LogDevice.DoLog until FlushQueue or Release are called
            </summary>
        </member>
        <member name="M:ATL.Logging.Log.FlushQueue">
            <summary>
            Flush all queued LogItems through call to LogDevice.DoLog
            </summary>
        </member>
        <member name="M:ATL.Logging.Log.SwitchSync">
            <summary>
            Make logging synchronous again and flushes remaining LogItems in queue
            </summary>
        </member>
        <member name="M:ATL.Logging.Log.getLevelName(System.Int32)">
            <summary>
            Get the name of the given logging level in english
            </summary>
            <param name="level">Logging level</param>
            <returns>Name of the given logging level</returns>
        </member>
        <member name="T:ATL.Logging.LogDelegator">
            <summary>
            This class is the static entry point for all logging operations
            </summary>
        </member>
        <member name="T:ATL.Logging.LogDelegator.LogWriteDelegate">
            Declaration of the delegate method signature for logging messages
        </member>
        <member name="T:ATL.Logging.LogDelegator.LogLocateDelegate">
            Declaration of the delegate method signature for setting location
        </member>
        <member name="F:ATL.Logging.LogDelegator.theLogWriteDelegate">
            Logging delegate object
            Initialized with a dummy method to avoid returning null
            when no call to SetLog has been made
        </member>
        <member name="F:ATL.Logging.LogDelegator.theLogLocateDelegate">
            Logging delegate object
            Initialized with a dummy method to avoid returning null
            when no call to SetLog has been made
        </member>
        <member name="M:ATL.Logging.LogDelegator.SetLog(ATL.Logging.Log@)">
            <summary>
            Sets the delegate to the Write method of the Log object 
            used for logging messages
            </summary>
            <param name="theLog">Log to be used</param> 
        </member>
        <member name="M:ATL.Logging.LogDelegator.GetLogDelegate">
            <summary>
            Gets the delegate routine to use for logging messages
            </summary>
            <returns>Delegate routine object to be used</returns>
        </member>
        <member name="M:ATL.Logging.LogDelegator.GetLocateDelegate">
            <summary>
            Gets the delegate routine to use for setting location
            </summary>
            <returns>Delegate routine object to be used</returns>
        </member>
        <member name="T:ATL.Playlist.IO.ASXIO">
            <summary>
            ASX playlist manager
            
            Implementation notes : Playlist items other than local files (e.g. file accessible via HTTP) are not supported
            </summary>
        </member>
        <member name="M:ATL.Playlist.IO.ASXIO.getFiles(System.IO.FileStream,System.Collections.Generic.IList{System.String})">
            <inheritdoc/>
        </member>
        <member name="M:ATL.Playlist.IO.ASXIO.setTracks(System.IO.FileStream,System.Collections.Generic.IList{ATL.Track})">
            <inheritdoc/>
        </member>
        <member name="T:ATL.Playlist.IO.B4SIO">
            <summary>
            B4S playlist manager
            </summary>
        </member>
        <member name="M:ATL.Playlist.IO.B4SIO.getFiles(System.IO.FileStream,System.Collections.Generic.IList{System.String})">
            <inheritdoc/>
        </member>
        <member name="M:ATL.Playlist.IO.B4SIO.setTracks(System.IO.FileStream,System.Collections.Generic.IList{ATL.Track})">
            <inheritdoc/>
        </member>
        <member name="T:ATL.Playlist.IO.DummyIO">
            <summary>
            Dummy playlist management class
            </summary>
        </member>
        <member name="P:ATL.Playlist.IO.DummyIO.Path">
            <inheritdoc/>
        </member>
        <member name="P:ATL.Playlist.IO.DummyIO.FilePaths">
            <inheritdoc/>
        </member>
        <member name="P:ATL.Playlist.IO.DummyIO.Tracks">
            <inheritdoc/>
        </member>
        <member name="P:ATL.Playlist.IO.DummyIO.LocationFormatting">
            <inheritdoc/>
        </member>
        <member name="P:ATL.Playlist.IO.DummyIO.Encoding">
            <inheritdoc/>
        </member>
        <member name="T:ATL.Playlist.IO.FPLIO">
            <summary>
            Foobar2000 EXPERIMENTAL playlist reader
            Since the format is not open and can be subject to change by
            fb2k developers at any time, this reader is experimental : it is not guaranteed 
            to work with all versions of FPL files
            </summary>
        </member>
        <member name="M:ATL.Playlist.IO.FPLIO.getFiles(System.IO.FileStream,System.Collections.Generic.IList{System.String})">
            <inheritdoc/>
        </member>
        <member name="M:ATL.Playlist.IO.FPLIO.setTracks(System.IO.FileStream,System.Collections.Generic.IList{ATL.Track})">
            <inheritdoc/>
        </member>
        <member name="T:ATL.Playlist.IO.M3UIO">
            <summary>
            M3U/M3U8 playlist manager
            </summary>
        </member>
        <member name="M:ATL.Playlist.IO.M3UIO.getFiles(System.IO.FileStream,System.Collections.Generic.IList{System.String})">
            <inheritdoc/>
        </member>
        <member name="M:ATL.Playlist.IO.M3UIO.setTracks(System.IO.FileStream,System.Collections.Generic.IList{ATL.Track})">
            <inheritdoc/>
        </member>
        <member name="T:ATL.Playlist.IO.PLSIO">
            <summary>
            PLS playlist manager
            </summary>
        </member>
        <member name="M:ATL.Playlist.IO.PLSIO.getFiles(System.IO.FileStream,System.Collections.Generic.IList{System.String})">
            <inheritdoc/>
        </member>
        <member name="M:ATL.Playlist.IO.PLSIO.setTracks(System.IO.FileStream,System.Collections.Generic.IList{ATL.Track})">
            <inheritdoc/>
        </member>
        <member name="T:ATL.Playlist.IO.SMILIO">
            <summary>
            SMIL playlist manager
            
            This is a very basic implementation that lists every single audio file in the playlist
            
            Implementation notes : Playlist items other than local files (e.g. file accessible via HTTP) are not supported
            </summary>
        </member>
        <member name="M:ATL.Playlist.IO.SMILIO.getFiles(System.IO.FileStream,System.Collections.Generic.IList{System.String})">
            <inheritdoc/>
        </member>
        <member name="M:ATL.Playlist.IO.SMILIO.setTracks(System.IO.FileStream,System.Collections.Generic.IList{ATL.Track})">
            <inheritdoc/>
        </member>
        <member name="T:ATL.Playlist.IO.XSPFIO">
            <summary>
            XSPF (spiff) playlist manager
            
            Implementation notes : Playlist items other than local files (e.g. file accessible via HTTP) are not supported
            </summary>
        </member>
        <member name="M:ATL.Playlist.IO.XSPFIO.getFiles(System.IO.FileStream,System.Collections.Generic.IList{System.String})">
            <inheritdoc/>
        </member>
        <member name="M:ATL.Playlist.IO.XSPFIO.setTracks(System.IO.FileStream,System.Collections.Generic.IList{ATL.Track})">
            <inheritdoc/>
        </member>
        <member name="T:ATL.Playlist.IPlaylistIO">
            <summary>
            Interface for standard playlist I/O classes
            </summary>
        </member>
        <member name="P:ATL.Playlist.IPlaylistIO.Path">
            <summary>
            Absolute path of the playlist file
            </summary>
        </member>
        <member name="P:ATL.Playlist.IPlaylistIO.LocationFormatting">
            <summary>
            Location formatting to use when writing the file
            </summary>
        </member>
        <member name="P:ATL.Playlist.IPlaylistIO.Encoding">
            <summary>
            Encoding convention to use when writing the file
            </summary>
        </member>
        <member name="P:ATL.Playlist.IPlaylistIO.FilePaths">
            <summary>
            Gets the absolute paths of all files registered in the playlist
            NB : The existence of the files is not checked when getting them
            </summary>
            <returns>Array containing all paths</returns>
        </member>
        <member name="P:ATL.Playlist.IPlaylistIO.Tracks">
            <summary>
            Gest all the tracks registered in the playlist
            </summary>
            <returns>Array containing all tracks</returns>
        </member>
        <member name="T:ATL.Playlist.PlaylistFormat">
            <summary>
            Defines the format of a playlist
            </summary>
        </member>
        <member name="T:ATL.Playlist.PlaylistFormat.LocationFormatting">
            <summary>
            Formatting of the track locations (file paths) within the playlist
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistFormat.LocationFormatting.Undefined">
            <summary>
            Undefined formatting
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistFormat.LocationFormatting.FilePath">
            <summary>
            File path (e.g. C:\the folder\theFile.mp3)
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistFormat.LocationFormatting.Winamp_URI">
            <summary>
            Winamp convention (e.g. file:C:\the folder\theFile.mp3)
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistFormat.LocationFormatting.MS_URI">
            <summary>
            Microsoft URI (e.g. file://C:\the folder\theFile.mp3)
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistFormat.LocationFormatting.RFC_URI">
            <summary>
            RFC URI (e.g. file:///C:/the%20folder/theFile.mp3)
            </summary>
        </member>
        <member name="T:ATL.Playlist.PlaylistFormat.FileEncoding">
            <summary>
            String encoding used within the playlist file
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistFormat.FileEncoding.Undefined">
            <summary>
            Undefined encoding
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistFormat.FileEncoding.UTF8_BOM">
            <summary>
            UTF-8 with file BOM
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistFormat.FileEncoding.UTF8_NO_BOM">
            <summary>
            UTF-8 without file BOM
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistFormat.FileEncoding.ANSI">
            <summary>
            ANSI (use at your own risk)
            </summary>
        </member>
        <member name="P:ATL.Playlist.PlaylistFormat.LocationFormat">
            <summary>
            Formatting of the track locations (file paths) within the playlist file
            </summary>
        </member>
        <member name="P:ATL.Playlist.PlaylistFormat.Encoding">
            <summary>
            String encoding used within the playlist file
            </summary>
        </member>
        <member name="M:ATL.Playlist.PlaylistFormat.#ctor(System.Int32,System.String)">
            <summary>
            Instanciate a new PlaylistFormat using the given arguments
            </summary>
            <param name="ID">Format ID</param>
            <param name="iName">Format name</param>
        </member>
        <member name="M:ATL.Playlist.PlaylistFormat.#ctor(ATL.Playlist.PlaylistFormat)">
            <summary>
            Instanciate a new PlaylistFormat by copying the given PlaylistFormat's attributes
            </summary>
            <param name="f">PlaylistFormat object to copy attributes from</param>
        </member>
        <member name="M:ATL.Playlist.PlaylistFormat.copyFrom(ATL.Format)">
            <summary>
            Copy the attributes of the given Format object
            </summary>
            <param name="iFormat">Format object to copy attributes from</param>
        </member>
        <member name="M:ATL.Playlist.PlaylistFormat.init(System.Int32,System.String)">
            <summary>
            Initialize the current object with the given ID and Name
            </summary>
            <param name="id">Format ID</param>
            <param name="name">Format name</param>
        </member>
        <member name="T:ATL.Playlist.PlaylistIO">
            <summary>
            Asbtract parent for all playlist manipulation (I/O) classes
            Contrains all common methods and attributes
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistIO.BOM_UTF8">
            <summary>
            Byte Order Mark of UTF-8 files
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistIO.UTF8_NO_BOM">
            <summary>
            .NET Encoding for UTF-8 with no Byte Order Mark
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistIO.ANSI">
            <summary>
            Latin-1 encoding used as ANSI
            </summary>
        </member>
        <member name="P:ATL.Playlist.PlaylistIO.Path">
            <summary>
            File Path of the playlist file
            </summary>
        </member>
        <member name="P:ATL.Playlist.PlaylistIO.LocationFormatting">
            <summary>
            Formatting of the track locations (file paths) within the playlist
            </summary>
        </member>
        <member name="P:ATL.Playlist.PlaylistIO.Encoding">
            <summary>
            String encoding used within the playlist file
            </summary>
        </member>
        <member name="P:ATL.Playlist.PlaylistIO.FilePaths">
            <summary>
            Paths of the track files described by the playlist
            </summary>
        </member>
        <member name="P:ATL.Playlist.PlaylistIO.Tracks">
            <summary>
            Track files described by the playlist
            </summary>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.getFiles(System.IO.FileStream,System.Collections.Generic.IList{System.String})">
            <summary>
            Read the paths of the track files described by the playlist using the given Stream
            and put them into the given list
            </summary>
            <param name="fs">FileStream to use to read the values</param>
            <param name="result">List that will receive the values</param>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.setTracks(System.IO.FileStream,System.Collections.Generic.IList{ATL.Track})">
            <summary>
            Read the tracks described by the playlist using the given Stream
            and put them into the given list
            </summary>
            <param name="fs">FileStream to use to read the tracks</param>
            <param name="result">List that will receive the tracks</param>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.getFiles">
            <summary>
            Read the paths of the track files described by the playlist
            </summary>
            <returns>List of the paths</returns>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.getTracks">
            <summary>
            Read the tracks described by the playlist
            </summary>
            <returns>List of the tracks</returns>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.setFiles(System.Collections.Generic.IList{System.String})">
            <summary>
            Modify playlist by replacing all file paths by the given file paths
            </summary>
            <param name="fileList">List of file paths to write in the playlist, replacing current ones</param>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.setTracks(System.Collections.Generic.IList{ATL.Track})">
            <summary>
            Modify playlist by replacing all tracks by the given tracks
            </summary>
            <param name="trackList">List of tracks to write in the playlist, replacing current ones</param>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.generateWriterSettings">
            <summary>
            Generate XmlWriterSettings from the current file's and global settings
            </summary>
            <returns>New instance of XmlWriterSettings</returns>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.encodeLocation(System.String)">
            <summary>
            Encodes the given location usingcurrent LocationFormatting
            </summary>
            <param name="location">File path to encode</param>
            <returns></returns>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.decodeLocation(System.Xml.XmlReader,System.String,System.Collections.Generic.IList{System.String})">
            <summary>
            Decodes the given location to an absolute filepath and adds it to the given list
            </summary>
            <param name="source">Xml source to get the location from</param>
            <param name="attributeName">Attribute name in current Xml source to get the location from</param>
            <param name="result">List of locations to add the found location to</param>
        </member>
        <member name="M:ATL.Playlist.PlaylistIO.decodeLocation(System.String)">
            <summary>
            Decodes the given location to an absolute filepath
            </summary>
            <param name="href">Location to decode (can be an URI of any form or a relative filepath)</param>
            <returns>Absolute filepath corresponding to the given location</returns>
        </member>
        <member name="T:ATL.Playlist.PlaylistIOFactory">
            <summary>
            Factory for playlist I/O classes
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistIOFactory.PL_M3U">
            <summary>
            M3U format
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistIOFactory.PL_PLS">
            <summary>
            PLS format
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistIOFactory.PL_FPL">
            <summary>
            FPL format
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistIOFactory.PL_XSPF">
            <summary>
            XSPF format
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistIOFactory.PL_SMIL">
            <summary>
            SMIL format
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistIOFactory.PL_ASX">
            <summary>
            ASX format
            </summary>
        </member>
        <member name="F:ATL.Playlist.PlaylistIOFactory.PL_B4S">
            <summary>
            B4S format
            </summary>
        </member>
        <member name="M:ATL.Playlist.PlaylistIOFactory.GetInstance">
            <summary>
            Get an instance of the factory
            </summary>
            <returns>Instance of the playlist factory</returns>
        </member>
        <member name="M:ATL.Playlist.PlaylistIOFactory.GetPlaylistIO(System.String,ATL.Playlist.PlaylistFormat.LocationFormatting,ATL.Playlist.PlaylistFormat.FileEncoding,System.Int32)">
            <summary>
            Create a new playlist management object from the given parameters
            </summary>
            <param name="path">Path of the playlist file to open</param>
            <param name="locationFormatting">Formatting of paths within the playlist</param>
            <param name="fileEncoding">Encoding of the file</param>
            <param name="alternate">Internal use; should be zero when called from outside</param>
            <returns></returns>
        </member>
        <member name="M:ATL.Playlist.PlaylistIOFactory.GetPlaylistIO(System.Int32)">
            <summary>
            Create a new playlist management object from the given playlist format code (see public constants in PlaylistIOFactory)
            </summary>
            <param name="formatId">Playlist format code of the object to create</param>
            <returns>New playlist management object correspondingf to the given code</returns>
        </member>
        <member name="T:ATL.Settings">
            <summary>
            Global settings for the behaviour of the library
            </summary>
        </member>
        <member name="F:ATL.Settings.FileBufferSize">
            <summary>
            Buffer size used for I/O operations, in bytes.
            Default : 512 bytes
            
            A higher value will consumre more RAM but will allow faster I/O on large files.
            Warning : The app will crash if you set a value higher than the file size itself.
            </summary>
        </member>
        <member name="F:ATL.Settings.ForceDiskIO">
            <summary>
            Force high-level I/O operations to be performed without zone buffering,
            resulting in higher disk usage, but lower RAM usage
            Default : false
            </summary>
        </member>
        <member name="F:ATL.Settings.AddNewPadding">
            <summary>
            Add padding to files that don't have it
            Default : false
            </summary>
        </member>
        <member name="F:ATL.Settings.PaddingSize">
            <summary>
            Size of the initial padding to add; size of max padding to use
            Default : 2048
            </summary>
        </member>
        <member name="F:ATL.Settings.InternalValueSeparator">
            <summary>
            Value separator character
            Read-only; for internal use
            </summary>
        </member>
        <member name="F:ATL.Settings.DisplayValueSeparator">
            <summary>
            Value separator character used to display multiple values within one field
            Default : ';'
            </summary>
        </member>
        <member name="F:ATL.Settings.ReadAllMetaFrames">
            <summary>
            If true, default Track behaviour reads all metadata frames, including those not described by IMetaDataIO
            Default : true
            </summary>
        </member>
        <member name="F:ATL.Settings.DefaultTextEncoding">
            <summary>
            Text encoding to use to handle text data where official specs don't set any standard
            Default : UTF-8
            </summary>
        </member>
        <member name="F:ATL.Settings.DefaultTagsWhenNoMetadata">
            <summary>
            Tag editing preferences : what tagging systems to use when audio file has no metadata ?
            NB1 : If more than one item, _all_ of them will be written
            NB2 : If Native tagging is not indicated here, it will _not_ be used
            
            Default : ID3v2 then Native tagging
            </summary>
        </member>
        <member name="F:ATL.Settings.UseFileNameWhenNoTitle">
            <summary>
            If true, file name (without the extension) will go to the Title field if metadata contains no title
            Default : true
            </summary>
        </member>
        <member name="F:ATL.Settings.UseLeadingZeroes">
            <summary>
            If true, use leading zeroes; number of digits is aligned on TOTAL fields or 2 digits if no total field
            Default : false
            </summary>
        </member>
        <member name="F:ATL.Settings.OverrideExistingLeadingZeroesFormat">
            <summary>
            If true, UseLeadingZeroes is always _applied_ regardless of the format of the original file; if false, formatting of the original file prevails
            Default : false
            </summary>
        </member>
        <member name="F:ATL.Settings.ID3v2_useExtendedHeaderRestrictions">
            <summary>
            ID3v2 : Always write CTOC frame when metadata contain at least one chapter
            Default : false
            </summary>
        </member>
        <member name="F:ATL.Settings.ID3v2_alwaysWriteCTOCFrame">
            <summary>
            ID3v2 : Always write CTOC frame when metadata contain at least one chapter
            Default : true
            </summary>
        </member>
        <member name="F:ATL.Settings.ID3v2_tagSubVersion">
            <summary>
            ID3v2 : Write metadata in ID3v2.[ID3v2_tagSubVersion] format
            Only 3 and 4 are supported so far - resp. ID3v2.3 and ID3v2.4
            Default : 4 (ID3v2.4)
            </summary>
        </member>
        <member name="F:ATL.Settings.ID3v2_forceAPICEncodingToLatin1">
            <summary>
            ID3v2 : Force the encoding of the APIC frame to ISO-8859-1/Latin-1 for Windows to be able to display the cover picture
            Disable it to write picture descriptions using non-western characters (japanese, cyrillic...)
            Default : true
            </summary>
        </member>
        <member name="F:ATL.Settings.ID3v2_forceUnsynchronization">
            <summary>
            ID3v2 : Set to true to force unsynchronization when writing ID3v2.3 or ID3v2.4 tags
            Default : false
            </summary>
        </member>
        <member name="F:ATL.Settings.MP4_createNeroChapters">
            <summary>
            MP4 : Set to true to always create chapters in Nero format (chpl)
            Default : true
            </summary>
        </member>
        <member name="F:ATL.Settings.MP4_createQuicktimeChapters">
            <summary>
            MP4 : Set to true to always create chapters in Quicktime format (chap)
            Default : true
            </summary>
        </member>
        <member name="F:ATL.Settings.MP4_keepExistingChapters">
            <summary>
            MP4 : Set to true to keep existing chapters (i.e. Nero or Quicktime)
            regardless of the other chapter creation options
            </summary>
        </member>
        <member name="F:ATL.Settings.MP4_readChaptersExclusive">
            <summary>
            MP4 : Set to read chapters :
              - 0 : From any available format
              - 1 : Only from Quicktime format (chap)
              - 2 : Only from Nero format (chpl)
              
            Warning : Using a value > 0 while updating files may delete the tag you've not chosen to read
            Default : 0
            </summary>
        </member>
        <member name="F:ATL.Settings.ASF_keepNonWMFieldsWhenRemovingTag">
            <summary>
            ASF/WMA : Keep non-"WM" fields when removing the tag
            Default : false
            </summary>
        </member>
        <member name="F:ATL.Settings.GYM_VGM_playbackRate">
            <summary>
            GYM and VGM : Force playback rate (Hz) to calculate track duration
            Set 0 to adjust to song properties
            Default : 0
            </summary>
        </member>
        <member name="F:ATL.Settings.M3U_useExtendedFormat">
            <summary>
            M3U : Use extended format to write the playlist
            Default : true
            </summary>
        </member>
        <member name="T:ATL.BufferedBinaryReader">
            <summary>
            Reads data from the given Stream using a forward buffer in order to reduce disk stress and have better control of when data is actually read from the disk.
            
            NB1 : Using BufferedBinaryReader instead of the classic BinaryReader create a 10% speed gain on the dev environment (MS .NET under Windows)
            
            NB2 : The interface of this class is designed to be called exactly like a BinaryReader in order to facilitate swapping in classes that use BinaryReader
            However, is does _not_ give access to BaseStream, in order to keep control on buffer and cursor positions.
            
            NB3 : This class implements Stream in order to be reusable in methods that take Stream as an input
            </summary>
        </member>
        <member name="P:ATL.BufferedBinaryReader.Position">
            Mandatory override to Stream.Position
        </member>
        <member name="P:ATL.BufferedBinaryReader.Length">
            Mandatory override to Stream.Length
        </member>
        <member name="P:ATL.BufferedBinaryReader.CanRead">
            Mandatory override to Stream.CanRead
        </member>
        <member name="P:ATL.BufferedBinaryReader.CanSeek">
            Mandatory override to Stream.CanSeek
        </member>
        <member name="P:ATL.BufferedBinaryReader.CanWrite">
            Mandatory override to Stream.CanWrite
        </member>
        <member name="M:ATL.BufferedBinaryReader.#ctor(System.IO.Stream)">
            <summary>
            Construct a new instance of BufferedBinaryReader using the given Stream
            </summary>
            <param name="stream">Stream to read</param>
        </member>
        <member name="M:ATL.BufferedBinaryReader.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Construct a new instance of BufferedBinaryReader using the given Stream and buffer size
            </summary>
            <param name="stream">Stream to read</param>
            <param name="bufferSize">Buffer size to use</param>
        </member>
        <member name="M:ATL.BufferedBinaryReader.Seek(System.Int64,System.IO.SeekOrigin)">
            Mandatory override to Stream.Seek
        </member>
        <member name="M:ATL.BufferedBinaryReader.Read(System.Byte[],System.Int32,System.Int32)">
            Mandatory override to Stream.Read
        </member>
        <member name="M:ATL.BufferedBinaryReader.ReadBytes(System.Int32)">
            <summary>
            Read an array of bytes of the given length from the current position
            </summary>
            <param name="nbBytes">Number of bytes to read</param>
            <returns>Array of bytes of the given length read from the current position</returns>
        </member>
        <member name="M:ATL.BufferedBinaryReader.ReadByte">
            <summary>
            Read a single byte from the current position
            </summary>
            <returns>Byte read from the current position</returns>
        </member>
        <member name="M:ATL.BufferedBinaryReader.ReadUInt16">
            <summary>
            Read a single unsigned Int16 from the current position
            </summary>
            <returns>Unsigned Int16 read from the current position</returns>
        </member>
        <member name="M:ATL.BufferedBinaryReader.ReadInt16">
            <summary>
            Read a single signed Int16 from the current position
            </summary>
            <returns>Signed Int16 read from the current position</returns>
        </member>
        <member name="M:ATL.BufferedBinaryReader.ReadUInt32">
            <summary>
            Read a single unsigned Int32 from the current position
            </summary>
            <returns>Unsigned Int32 read from the current position</returns>
        </member>
        <member name="M:ATL.BufferedBinaryReader.ReadInt32">
            <summary>
            Read a single signed Int32 from the current position
            </summary>
            <returns>Signed Int32 read from the current position</returns>
        </member>
        <member name="M:ATL.BufferedBinaryReader.ReadUInt64">
            <summary>
            Read a single unsigned Int64 from the current position
            </summary>
            <returns>Unsigned Int64 read from the current position</returns>
        </member>
        <member name="M:ATL.BufferedBinaryReader.ReadInt64">
            <summary>
            Read a single signed Int64 from the current position
            </summary>
            <returns>Signed Int64 read from the current position</returns>
        </member>
        <member name="M:ATL.BufferedBinaryReader.Dispose">
            Override to IDisposable.Dispose
        </member>
        <member name="M:ATL.BufferedBinaryReader.Flush">
            Mandatory override to Stream.Flush
        </member>
        <member name="M:ATL.BufferedBinaryReader.SetLength(System.Int64)">
            Mandatory override to Stream.SetLength
        </member>
        <member name="M:ATL.BufferedBinaryReader.Write(System.Byte[],System.Int32,System.Int32)">
            Mandatory override to Stream.Write
        </member>
        <member name="T:ATL.StreamUtils">
            <summary>
            Misc. utilities used by binary readers
            </summary>
        </member>
        <member name="T:ATL.StreamUtils.StreamHandlerDelegate">
            <summary>
            Handler signature to be used when needing to process a MemoryStream
            </summary>
        </member>
        <member name="M:ATL.StreamUtils.StringEqualsArr(System.String,System.Char[])">
            <summary>
            Determines if the contents of a string (character by character) is the same
            as the contents of a char array
            </summary>
            <param name="a">String to be tested</param>
            <param name="b">Char array to be tested</param>
            <returns>True if both contain the same character sequence; false if not</returns>
        </member>
        <member name="M:ATL.StreamUtils.ArrEqualsArr(System.Char[],System.Char[])">
            <summary>
            Determines if two char arrays have the same contents
            </summary>
            <param name="a">First array to be tested</param>
            <param name="b">Second array to be tested</param>
            <returns>True if both arrays have the same contents; false if not</returns>
        </member>
        <member name="M:ATL.StreamUtils.ArrEqualsArr(System.Byte[],System.Byte[])">
            <summary>
            Determines if two byte arrays have the same contents
            </summary>
            <param name="a">First array to be tested</param>
            <param name="b">Second array to be tested</param>
            <returns>True if both arrays have the same contents; false if not</returns>
        </member>
        <member name="M:ATL.StreamUtils.CopyStream(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>
            Copies a given number of bytes from a given stream to another, starting at current stream positions
            i.e. first byte will be read at from.Position and written at to.Position
            NB : This method cannot be used to move data within one single stream; use CopySameStream instead
            </summary>
            <param name="from">Stream to start copy from</param>
            <param name="to">Stream to copy to</param>
            <param name="length">Number of bytes to copy (optional; default = 0 = all bytes until the end of the 'from' stream)</param>
        </member>
        <member name="M:ATL.StreamUtils.CopySameStream(System.IO.Stream,System.Int64,System.Int64,System.Int32)">
            <summary>
            Copy data between the two given offsets within the given stream
            </summary>
            <param name="s">Stream to process</param>
            <param name="offsetFrom">Starting offset to copy data from</param>
            <param name="offsetTo">Starting offset to copy data to</param>
            <param name="length">Length of the data to copy</param>
        </member>
        <member name="M:ATL.StreamUtils.CopySameStream(System.IO.Stream,System.Int64,System.Int64,System.Int32,System.Int32)">
            <summary>
            Copy data between the two given offsets within the given stream, using the given buffer size
            </summary>
            <param name="s">Stream to process</param>
            <param name="offsetFrom">Starting offset to copy data from</param>
            <param name="offsetTo">Starting offset to copy data to</param>
            <param name="length">Length of the data to copy</param>
            <param name="bufferSize">Buffer size to use during the operation</param>
        </member>
        <member name="M:ATL.StreamUtils.ShortenStream(System.IO.Stream,System.Int64,System.UInt32)">
            <summary>
            Remove a portion of bytes within the given stream
            </summary>
            <param name="s">Stream to process; must be accessible for reading and writing</param>
            <param name="endOffset">End offset of the portion of bytes to remove</param>
            <param name="delta">Number of bytes to remove</param>
        </member>
        <member name="M:ATL.StreamUtils.LengthenStream(System.IO.Stream,System.Int64,System.UInt32,System.Boolean)">
            <summary>
            Add bytes within the given stream
            </summary>
            <param name="s">Stream to process; must be accessible for reading and writing</param>
            <param name="oldIndex">Offset where to add new bytes</param>
            <param name="delta">Number of bytes to add</param>
            <param name="fillZeroes">If true, new bytes will all be zeroes (optional; default = false)</param>
        </member>
        <member name="M:ATL.StreamUtils.DecodeSignedByte(System.Byte[])">
            <summary>
            Decode an signed byte from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeUByte(System.Byte[])">
            <summary>
            Decode an unsigned byte from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEUInt16(System.Byte[])">
            <summary>
            Decode an unsigned Big-Endian 16-bit integer from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEUInt16(System.UInt16)">
            <summary>
            Encode the given value into an array of bytes as a Big-Endian 16-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeUInt16(System.Byte[])">
            <summary>
            Decode an unsigned Little-Endian 16-bit integer from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeInt16(System.Byte[])">
            <summary>
            Decode an signed Little-Endian 16-bit integer from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEInt16(System.Int16)">
            <summary>
            Encode the given value into an array of bytes as a Big-Endian 16-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEInt16(System.Byte[])">
            <summary>
            Decode a signed Big-Endian 16-bit integer from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEInt24(System.Byte[])">
            <summary>
            Decode a signed Big-Endian 24-bit integer from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEUInt24(System.Byte[],System.Int32)">
            <summary>
            Decode an unsigned Big-Endian 24-bit integer from the given array of bytes, starting from the given offset
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <param name="offset">Offset to read value from (default : 0)</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEUInt24(System.UInt32)">
            <summary>
            Encode the given value into an array of bytes as a Big-Endian 24-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEUInt32(System.Byte[])">
            <summary>
            Decode an unsigned Big-Endian 32-bit integer from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeUInt32(System.Byte[])">
            <summary>
            Decode an unsigned Little-Endian 32-bit integer from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEUInt32(System.UInt32)">
            <summary>
            Encode the given value into an array of bytes as a Big-Endian unsigned 32-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEInt32(System.Byte[])">
            <summary>
            Decode a signed Big-Endian 32-bit integer from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEInt32(System.Int32)">
            <summary>
            Encode the given value into an array of bytes as a Big-Endian 32-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeInt32(System.Byte[])">
            <summary>
            Decode a signed Little-Endian 32-bit integer from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeUInt64(System.Byte[])">
            <summary>
            Decode an unsigned Little-Endian 64-bit integer from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeBEInt64(System.Byte[])">
            <summary>
            Decode a signed Big-Endian 64-bit integer from the given array of bytes
            </summary>
            <param name="data">Array of bytes to read value from</param>
            <returns>Decoded value</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeBEUInt64(System.UInt64)">
            <summary>
            Encode the given value into an array of bytes as a Big-Endian unsigned 64-bits integer
            </summary>
            <param name="value">Value to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.ReverseInt32(System.Int32)">
            <summary>
            Switch the format of a signed Int32 between big endian and little endian
            </summary>
            <param name="n">value to convert</param>
            <returns>converted value</returns>
        </member>
        <member name="M:ATL.StreamUtils.GetEncodingFromFileBOM(System.IO.FileStream)">
            <summary>
            Guess the encoding from the file Byte Order Mark (BOM)
            http://en.wikipedia.org/wiki/Byte_order_mark 
            NB : This obviously only works for files that actually start with a BOM
            </summary>
            <param name="file">FileStream to read from</param>
            <returns>Detected encoding; system Default if detection failed</returns>
        </member>
        <member name="M:ATL.StreamUtils.ReadNullTerminatedString(System.IO.BinaryReader,System.Text.Encoding)">
            <summary>
            Read a null-terminated String from the given BinaryReader, according to the given Encoding
            Returns with the BinaryReader positioned after the last null-character(s)
            </summary>
            <param name="r">BinaryReader positioned at the beginning of the String to be read</param>
            <param name="encoding">Encoding to use for reading the stream</param>
            <returns>Read value</returns>
        </member>
        <member name="M:ATL.StreamUtils.ReadNullTerminatedString(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Read a null-terminated String from the given Stream, according to the given Encoding
            Returns with the BinaryReader positioned after the last null-character(s)
            </summary>
            <param name="s">Stream positioned at the beginning of the String to be read</param>
            <param name="encoding">Encoding to use for reading the stream</param>
            <returns>Read value</returns>
        </member>
        <member name="M:ATL.StreamUtils.ReadNullTerminatedStringFixed(System.IO.BinaryReader,System.Text.Encoding,System.Int32)">
            <summary>
            Read a null-terminated String from the given BinaryReader, according to the given Encoding, within a given limit of bytes
            Returns with the BinaryReader positioned at (start+limit)
            </summary>
            <param name="r">BinaryReader positioned at the beginning of the String to be read</param>
            <param name="encoding">Encoding to use for reading the stream</param>
            <param name="limit">Maximum number of bytes to read</param>
            <returns>Read value</returns>
        </member>
        <member name="M:ATL.StreamUtils.ReadNullTerminatedStringFixed(ATL.BufferedBinaryReader,System.Text.Encoding,System.Int32)">
            <summary>
            Read a null-terminated String from the given BufferedBinaryReader, according to the given Encoding, within a given limit of bytes
            Returns with the BinaryReader positioned at (start+limit)
            </summary>
            <param name="r">BufferedBinaryReader positioned at the beginning of the String to be read</param>
            <param name="encoding">Encoding to use for reading the stream</param>
            <param name="limit">Maximum number of bytes to read</param>
            <returns>Read value</returns>
        </member>
        <member name="M:ATL.StreamUtils.readNullTerminatedString(System.IO.Stream,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Read a null-terminated string using the giver BinaryReader
            </summary>
            <param name="r">Stream reader to read the string from</param>
            <param name="encoding">Encoding to use to parse the read bytes into the resulting String</param>
            <param name="limit">Limit (in bytes) of read data (0=unlimited)</param>
            <param name="moveStreamToLimit">Indicates if the stream has to advance to the limit before returning</param>
            <returns>The string read, without the zeroes at its end</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeSynchSafeInt(System.Byte[])">
            <summary>
            Extract a signed 32-bit integer from a byte array using the "synch-safe" convention
            as to ID3v2 definition (§6.2)
            </summary>
            <param name="bytes">Byte array containing data
            NB : Array size can vary from 1 to 5 bytes, as only 7 bits of each is actually used
            </param>
            <returns>Decoded Int32</returns>
        </member>
        <member name="M:ATL.StreamUtils.DecodeSynchSafeInt32(System.Byte[])">
            <summary>
            Decode a signed 32-bit integer from a 4-byte array using the "synch-safe" convention
            as to ID3v2 definition (§6.2)
            NB : The actual capacity of the integer thus reaches 28 bits
            </summary>
            <param name="data">4-byte array containing to convert</param>
            <returns>Decoded Int32</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeSynchSafeInt(System.Int32,System.Int32)">
            <summary>
            Encode the given values as a (nbBytes*8)-bit integer to a (nbBytes)-byte array using the "synch-safe" convention
            as to ID3v2 definition (§6.2)
            </summary>
            <param name="value">Value to encode</param>
            <param name="nbBytes">Number of bytes to encode to (can be 1 to 5)</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.EncodeSynchSafeInt32(System.Int32)">
            <summary>
            Encode the given value as a 32-bit integer to a 4-byte array using the "synch-safe" convention
            as to ID3v2 definition (§6.2)
            </summary>
            <param name="value">Integer to be encoded</param>
            <returns>Encoded array of bytes</returns>
        </member>
        <member name="M:ATL.StreamUtils.FindSequence(System.IO.Stream,System.Byte[],System.Int64)">
            <summary>
            Find a byte sequence within a stream
            </summary>
            <param name="stream">Stream to search into</param>
            <param name="sequence">Sequence to find</param>
            <param name="limit">Maximum distance (in bytes) of the sequence to find.
            Put 0 for an infinite distance</param>
            <returns>
                true if the sequence has been found; the stream will be positioned on the 1st byte following the sequence
                false if the sequence has not been found; the stream will keep its initial position
            </returns>
        </member>
        <member name="M:ATL.StreamUtils.ReadBits(System.IO.BinaryReader,System.Int32,System.Int32)">
            <summary>
            Read the given number of bits from the given position and converts it to an unsigned int32
            according to big-endian convention
            
            NB : reader position _always_ progresses by 4, no matter how many bits are needed
            </summary>
            <param name="source">BinaryReader to read the data from</param>
            <param name="bitPosition">Position of the first _bit_ to read (scale is x8 compared to classic byte positioning) </param>
            <param name="bitCount">Number of bits to read</param>
            <returns>Unsigned int32 formed from read bits, according to big-endian convention</returns>
        </member>
        <member name="M:ATL.StreamUtils.ExtendedToDouble(System.Byte[])">
            <summary>
            Convert the given extended-format byte array (which is assumed to be in little-endian form) to a .NET Double,
            as closely as possible.Values which are too small to be
            represented are returned as an appropriately signed 0. 
            Values which are too large to be represented (but not infinite) 
            are returned as Double.NaN, as are unsupported values and actual NaN values.
            
            Credits : Jon Skeet (http://groups.google.com/groups?selm=MPG.19a6985d4683f5d398a313%40news.microsoft.com)
            </summary>
            <param name="extended">Extended data to be converted</param>
            <returns>Converted value, or Double.NaN if unsupported or NaN</returns>
        </member>
        <member name="M:ATL.StreamUtils.FromComponents(System.Int32,System.Int32,System.Int64)">
            <summary>
            Returns a double from the IEEE sign/exponent/fraction components
            
            Credits : Jon Skeet (http://groups.google.com/groups?selm=MPG.19a6985d4683f5d398a313%40news.microsoft.com)
            </summary>
            <param name="s">IEEE sign component</param>
            <param name="e">IEEE exponent component</param>
            <param name="f">IEEE fraction component</param>
            <returns>Converted double</returns>
        </member>
        <member name="M:ATL.StreamUtils.TraversePadding(System.IO.Stream)">
            <summary>
            Advance the given Stream until something else than \0 is encountered.
            NB : A series of successive \0's is called "padding zone"
            
            Warning : There is no contract regarding the position within the stream at the end of the call.
            It might be anywhere around the end of the padding zone.
            </summary>
            <param name="source">Stream to advance, positioned at the beginning of a padding zone</param>
            <returns>Absolute offset of the end of the padding zone within the given Stream</returns>
        </member>
        <member name="T:ATL.Version">
            <summary>
            Represents the current version of Audio Tools Library
            </summary>
        </member>
        <member name="M:ATL.Version.getVersion">
            <summary>
            Get the current version of Audio Tools Library
            </summary>
            <returns>Current version of Audio Tools Library</returns>
        </member>
        <member name="T:HashDepot.FNV1a">
            <summary>
            FNV-1a Hash functions
            </summary>
        </member>
        <member name="M:HashDepot.FNV1a.Hash32(System.Byte[])">
            <summary>
            Calculate 32-bit FNV-1a hash value
            </summary>
        </member>
        <member name="T:Commons.ImageFormat">
            <summary>
            Describe an image format
            </summary>
        </member>
        <member name="F:Commons.ImageFormat.Unsupported">
            <summary>
            Unsupported (i.e. none of the other supported formats in the enum)
            </summary>
        </member>
        <member name="F:Commons.ImageFormat.Undefined">
            <summary>
            Undefined
            </summary>
        </member>
        <member name="F:Commons.ImageFormat.Jpeg">
            <summary>
            JPEG
            </summary>
        </member>
        <member name="F:Commons.ImageFormat.Gif">
            <summary>
            GIF
            </summary>
        </member>
        <member name="F:Commons.ImageFormat.Png">
            <summary>
            PNG
            </summary>
        </member>
        <member name="F:Commons.ImageFormat.Bmp">
            <summary>
            Bitmap
            </summary>
        </member>
        <member name="F:Commons.ImageFormat.Tiff">
            <summary>
            TIFF
            </summary>
        </member>
        <member name="T:Commons.ImageProperties">
            <summary>
            Struct class definining the properties of an image
            </summary>
        </member>
        <member name="F:Commons.ImageProperties.Format">
            <summary>
            Image format
            </summary>
        </member>
        <member name="F:Commons.ImageProperties.Width">
            <summary>
            Width, in pixels
            </summary>
        </member>
        <member name="F:Commons.ImageProperties.Height">
            <summary>
            Height, in pixels
            </summary>
        </member>
        <member name="F:Commons.ImageProperties.ColorDepth">
            <summary>
            Color depth, in bits
            </summary>
        </member>
        <member name="F:Commons.ImageProperties.NumColorsInPalette">
            <summary>
            Number of colors supported by the palette
            </summary>
        </member>
        <member name="T:Commons.ImageUtils">
            <summary>
            Helper methods for reading basic image properties without System.Drawing
            This class has been created to reach .NET Core 2.0 compatibility
            
            Implementation notes :
              - If a TIFF file has multiple images, only the properties of the 1st image will be read
              - BMPs with color palettes are not supported
            </summary>
        </member>
        <member name="M:Commons.ImageUtils.GetMimeTypeFromImageFormat(Commons.ImageFormat)">
            <summary>
            Return the mime-type of the given .NET image format
            NB : This function is restricted to most common embedded picture formats : JPEG, GIF, PNG, BMP
            </summary>
            <param name="imageFormat">Image format whose mime-type to obtain</param>
            <returns>mime-type of the given image format</returns>
        </member>
        <member name="M:Commons.ImageUtils.GetImageFormatFromMimeType(System.String)">
            <summary>
            Returns the .NET image format of the given mime-type
            NB1 : This function is restricted to most common embedded picture formats : JPEG, GIF, PNG, BMP
            NB2 : This function does not verify the syntax of the mime-type (e.g. "image/XXX"), and only focuses on the presence of specific substrings (e.g. "gif")
            </summary>
            <param name="mimeType">Mime-type whose ImageFormat to obtain</param>
            <returns>ImageFormat of the given mime-type (default : JPEG)</returns>
        </member>
        <member name="M:Commons.ImageUtils.GetImageFormatFromPictureHeader(System.Byte[])">
            <summary>
            Detects image format from the given signature
            </summary>
            <param name="header">Binary signature; must be at least 3-bytes long</param>
            <returns>Detected image format corresponding to the given signature; null if no match is found</returns>
        </member>
        <member name="M:Commons.ImageUtils.GetImageProperties(System.Byte[],Commons.ImageFormat)">
            <summary>
            Detect the properties of the given image
            </summary>
            <param name="imageData">Raw picture data</param>
            <param name="format">Format of the picture (optional; will try to find it if not set)</param>
            <returns>Properties of the given image</returns>
        </member>
        <member name="T:Commons.Utils">
            <summary>
            General utility class
            </summary>
        </member>
        <member name="F:Commons.Utils.UNICODE_INVISIBLE_EMPTY">
            <summary>
            'ZERO WIDTH NO-BREAK SPACE' invisible character, sometimes used by certain tagging softwares
            </summary>
        </member>
        <member name="T:Commons.Utils.voidDelegate">
            <summary>
            Define a delegate that does not carry any argument (useful for "pinging")
            </summary>
        </member>
        <member name="P:Commons.Utils.Latin1Encoding">
            <summary>
            ISO-8859-1 encoding
            </summary>
        </member>
        <member name="M:Commons.Utils.ProtectValue(System.String)">
            <summary>
            Transform the given string so that is becomes non-null
            </summary>
            <param name="value">String to protect</param>
            <returns>Given string if non-null; else empty string</returns>
        </member>
        <member name="M:Commons.Utils.EncodeTimecode_ms(System.Int64)">
            <summary>
            Format the given duration using the following format
                DDdHH:MM:SS.UUUU
                
             Where
                DD is the number of days, if applicable (i.e. durations of less than 1 day won't display the "DDd" part)
                HH is the number of hours, if applicable (i.e. durations of less than 1 hour won't display the "HH:" part)
                MM is the number of minutes
                SS is the number of seconds
                UUUU is the number of milliseconds
            </summary>
            <param name="milliseconds">Duration to format (in milliseconds)</param>
            <returns>Formatted duration according to the abovementioned convention</returns>
        </member>
        <member name="M:Commons.Utils.EncodeTimecode_s(System.Int64)">
            <summary>
            Format the given duration using the following format
                DDdHH:MM:SS
                
             Where
                DD is the number of days, if applicable (i.e. durations of less than 1 day won't display the "DDd" part)
                HH is the number of hours, if applicable (i.e. durations of less than 1 hour won't display the "HH:" part)
                MM is the number of minutes
                SS is the number of seconds
            </summary>
            <param name="seconds">Duration to format (in seconds)</param>
            <returns>Formatted duration according to the abovementioned convention</returns>
        </member>
        <member name="M:Commons.Utils.DecodeTimecodeToMs(System.String)">
            <summary>
            Convert the duration of the given timecode to milliseconds
            Supported formats : hh:mm, hh:mm:ss.ddd, mm:ss, hh:mm:ss and mm:ss.ddd
            </summary>
            <param name="timeCode">Timecode to convert</param>
            <returns>Duration of the given timecode expressed in milliseconds if succeeded; -1 if failed</returns>
        </member>
        <member name="M:Commons.Utils.StripEndingZeroChars(System.String)">
            <summary>
            Strip the given string from all ending null '\0' characters
            </summary>
            <param name="iStr">String to process</param>
            <returns>Given string, without any ending null character</returns>
        </member>
        <member name="M:Commons.Utils.BuildStrictLengthString(System.Int32,System.Int32,System.Char,System.Boolean)">
            <summary>
            Transform the given number to format with the given length, expressed in number of characters
             - If the given length is shorter than the actual length of the string, it will be truncated
             - If the given length is longer than the actual length of the string, it will be right/left-padded with a given character
            </summary>
            <param name="value">Value to transform</param>
            <param name="length">Target length of the final string</param>
            <param name="paddingChar">Character to use if padding is needed</param>
            <param name="padRight">True if the padding has to be done on the right-side of the target string; 
            false if the padding has to be done on the left-side (optional; default value = true)</param>
            <returns>Reprocessed string of given length, according to rules documented in the method description</returns>
        </member>
        <member name="M:Commons.Utils.BuildStrictLengthString(System.String,System.Int32,System.Char,System.Boolean)">
            <summary>
            Transform the given string to format with the given length, expressed in number of characters
             - If the given length is shorter than the actual length of the string, it will be truncated
             - If the given length is longer than the actual length of the string, it will be right/left-padded with a given character
            </summary>
            <param name="value">Value to transform</param>
            <param name="length">Target length of the final string</param>
            <param name="paddingChar">Character to use if padding is needed</param>
            <param name="padRight">True if the padding has to be done on the right-side of the target string; 
            false if the padding has to be done on the left-side (optional; default value = true)</param>
            <returns>Reprocessed string of given length, according to rules documented in the method description</returns>
        </member>
        <member name="M:Commons.Utils.BuildStrictLengthStringBytes(System.String,System.Int32,System.Byte,System.Text.Encoding,System.Boolean)">
            <summary>
            Transform the given string to format with the given length, expressed in number of bytes
             - If the given length is shorter than the actual length of the string, it will be truncated
             - If the given length is longer than the actual length of the string, it will be right/left-padded with a given byte
            </summary>
            <param name="value">String to transform</param>
            <param name="targetLength">Target length of the final string</param>
            <param name="paddingByte">Byte to use if padding is needed</param>
            <param name="encoding">Encoding to use to represent the given string in binary format</param>
            <param name="padRight">True if the padding has to be done on the right-side of the target string; 
            false if the padding has to be done on the left-side (optional; default value = true)</param>
            <returns>Reprocessed string of given length, in binary format, according to rules documented in the method description</returns>
        </member>
        <member name="M:Commons.Utils.ToBoolean(System.String)">
            <summary>
            Covert given string value to boolean.
              - Returns true if string represents a non-null numeric value or the word "true"
              - Returns false if not
              
            NB : This implementation exists because default .NET implementation has a different convention as for parsing numbers
            </summary>
            <param name="value">Value to be converted</param>
            <returns>Resulting boolean value</returns>
        </member>
        <member name="M:Commons.Utils.DecodeFrom64(System.Byte[])">
            <summary>
            Decode the given Base64 string
            Source : http://blogs.microsoft.co.il/blogs/mneiter/archive/2009/03/22/how-to-encoding-and-decoding-base64-strings-in-c.aspx
            </summary>
            <param name="encodedData">String containing the characters to decode</param>
            <returns>Decoded data</returns>
        </member>
        <member name="M:Commons.Utils.EncodeTo64(System.Byte[])">
            <summary>
            Convert the given input to a Base64 UUencoded output
            </summary>
            <param name="data">Data to be encoded</param>
            <returns>Encoded data</returns>
        </member>
        <member name="M:Commons.Utils.IsNumeric(System.String,System.Boolean)">
            <summary>
            Indicate if the given string is exclusively composed of digital charachers
            
            NB1 : decimal separators '.' and ',' are tolerated except if allowsOnlyIntegers argument is set to True
            NB2 : whitespaces ' ' are not tolerated
            NB3 : any alternate notation (e.g. exponent, hex) is not tolerated
            </summary>
            <param name="s">String to analyze</param>
            <param name="allowsOnlyIntegers">Set to True if IsNumeric should reject decimal values; default = false</param>
            <returns>True if the string is a digital value; false if not</returns>
        </member>
        <member name="M:Commons.Utils.IsHex(System.String)">
            <summary>
            Indicate if the given string is hexadecimal notation
            </summary>
            <param name="s">String to analyze</param>
            <returns>True if the string is a hexadecimal notation; false if not</returns>
        </member>
        <member name="M:Commons.Utils.ParseDouble(System.String)">
            <summary>
            Parse the given string into a float value; returns 0 if parsing fails
            </summary>
            <param name="s">String to be parsed</param>
            <returns>Parsed value; 0 if a parsing issue has been encountered</returns>
        </member>
        <member name="M:Commons.Utils.GetBytesReadable(System.Int64)">
            <summary>
            Return the human-readable file size for an arbitrary, 64-bit file size 
            The default format is "0.### XB", e.g. "4.2 KB" or "1.434 GB"
            Source : https://www.somacon.com/p576.php
            </summary>
            <param name="i">Size to display in a human-readable form</param>
            <returns>Given size displayed in a human-readable form</returns>
        </member>
    </members>
</doc>
